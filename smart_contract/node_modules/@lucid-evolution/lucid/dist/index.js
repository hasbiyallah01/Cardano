// src/core.ts
import { Effect } from "effect";
import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
var makeReturn = (program) => {
  return {
    unsafeRun: () => Effect.runPromise(program),
    safeRun: () => Effect.runPromise(Effect.either(program)),
    program: () => program
  };
};

// src/lucid-evolution/utils.ts
import { fromUnit, toUnit } from "@lucid-evolution/utils";
import { Data } from "@lucid-evolution/plutus";
var datumOf = async (provider, utxo, type) => {
  if (!utxo.datum) {
    if (!utxo.datumHash) {
      throw new Error("This UTxO does not have a datum hash.");
    }
    utxo.datum = await provider.getDatum(utxo.datumHash);
  }
  return Data.from(utxo.datum, type);
};
var metadataOf = async (provider, unit) => {
  const { policyId, name, label } = fromUnit(unit);
  switch (label) {
    case 222:
    case 333:
    case 444: {
      const utxo = await provider.getUtxoByUnit(toUnit(policyId, name, 100));
      const metadata = await datumOf(provider, utxo);
      return Data.toJson(metadata.fields[0]);
    }
    default:
      throw new Error("No variant matched.");
  }
};

// src/lucid-evolution/LucidEvolution.ts
import {
  createCostModels,
  unixTimeToSlot as unixTimeToSlot2
} from "@lucid-evolution/utils";

// src/tx-builder/internal/Collect.ts
import { Effect as Effect4, pipe as pipe2 } from "effect";
import { Data as Data4 } from "@lucid-evolution/plutus";
import { utxoToCore } from "@lucid-evolution/utils";

// src/Errors.ts
import { Data as Data2 } from "effect";
var ERROR_MESSAGE = {
  MULTIPLE_POLICIES: "MULTIPLE_POLICIES: Only one policy id allowed. You can chain multiple mintAssets functions together if you need to mint assets with different policy ids. ",
  EMPTY_UTXO: "EMPTY_UTXO: UTxO array is empty. If a Tx has been recently submitted, consider waiting for chain sync",
  MISSING_WALLET: "MISSING_WALLET: please ensure that your wallet has been properly configured and initialized",
  MISSING_REDEEMER: "MISSING_REDEEMER: redeemer can not be undefined",
  DATUM_NOT_SET: "DATUM_NOT_SET: Script inputs becomes unspendable without datum.",
  EMPTY_ASSETS: "EMPTY_ASSETS: Attempting to pay to an address with an empty assets object",
  MISSING_REWARD_TYPE: "MISSING_REWARD_TYPE: Address type must be Reward type.",
  MISSING_STAKE_CREDENTIAL: "MISSING_STAKE_CREDENTIAL: Address does not contain stake credential",
  MISSING_PAYMENT_CREDENTIAL: "MISSING_PAYMENT_CREDENTIAL: Address does not contain payment credential",
  INVALID_METADATA: "INVALID_METADATA: metadata is invalid",
  SCRIPT_CREDENTIAL_NOT_ALLOWED: "SCRIPT_CREDENTIAL_NOT_ALLOWED: Only verification key credential is allowed",
  INVALID_SCRIPT: "INVALID_SCRIPT: Script is invalid",
  EXPECTED_KEY_HASH: "EXPECTED_KEY_HASH",
  INVALID_NETWORK: (address, actualNetworkId, network) => `Invalid address: ${address}, Expected address with network id ${actualNetworkId}, current network ${network}`,
  MISSING_SCRIPT: (hash) => `MISSING_SCRIPT: Script not found when building transaction, consider using attach modules. script_hash: ${hash}`,
  MISSING_POLICY: (policyId) => `MISSING_POLICY: No policy found, policy_id: ${policyId}`
};
var NullableError = class extends Data2.TaggedError("NullableError") {
};
var UnauthorizedNetwork = class extends Data2.TaggedError(
  "UnauthorizedNetwork"
) {
};
var TxBuilderError = class extends Data2.TaggedError("TxBuilderError") {
  get message() {
    return `${this.cause}`;
  }
};
var TxSignerError = class extends Data2.TaggedError("TxSignerError") {
  get message() {
    return `${this.cause}`;
  }
};
var TxSubmitError = class extends Data2.TaggedError("TxSubmitError") {
  get message() {
    return `${this.cause}`;
  }
};
var RunTimeError = class extends Data2.TaggedError("RunTimeError") {
  get message() {
    return `${this.cause}`;
  }
};

// src/tx-builder/internal/Collect.ts
import * as CML3 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";

// src/tx-builder/internal/TxUtils.ts
import * as CML2 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
import { Effect as Effect2, pipe } from "effect";
import { networkToId, getAddressDetails } from "@lucid-evolution/utils";
import { Data as Data3 } from "@lucid-evolution/plutus";
var txBuilderError = (cause) => new TxBuilderError({ cause: `{ TxBuilderError : ${cause} }` });
var toCMLAddress = (address, lucidConfig) => Effect2.gen(function* ($) {
  const { type } = yield* validateAddressDetails(address, lucidConfig);
  return type === "Byron" ? CML2.ByronAddress.from_base58(address).to_address() : CML2.Address.from_bech32(address);
});
var toV1 = (script) => CML2.PlutusScript.from_v1(CML2.PlutusV1Script.from_cbor_hex(script));
var toV2 = (script) => CML2.PlutusScript.from_v2(CML2.PlutusV2Script.from_cbor_hex(script));
var toV3 = (script) => CML2.PlutusScript.from_v3(CML2.PlutusV3Script.from_cbor_hex(script));
var toPartial = (script, redeemer) => CML2.PartialPlutusWitness.new(
  CML2.PlutusScriptWitness.new_script(script),
  CML2.PlutusData.from_cbor_hex(redeemer)
);
var handleRedeemerBuilder = (config, partialProgram, redeemer) => {
  if (typeof redeemer === "object") {
    config.partialPrograms.set(redeemer, partialProgram);
  } else {
    const program = partialProgram(redeemer);
    config.programs.push(program);
  }
};
var validateAddressDetails = (address, lucidConfig) => Effect2.gen(function* ($) {
  const addressDetails = yield* $(
    Effect2.try({
      try: () => getAddressDetails(address),
      catch: (cause) => new TxBuilderError({
        cause
      })
    })
  );
  const actualNetworkId = networkToId(lucidConfig.network);
  if (addressDetails.networkId !== actualNetworkId)
    yield* new TxBuilderError({
      cause: ERROR_MESSAGE.INVALID_NETWORK(
        address,
        actualNetworkId,
        lucidConfig.network
      )
    });
  return addressDetails;
});
var processCertificate = (stakeCredential, config, buildCert, redeemer) => Effect2.gen(function* () {
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML2.Credential.new_pub_key(
        CML2.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = buildCert(credential);
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML2.Credential.new_script(
        CML2.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = buildCert(credential);
      const script = yield* pipe(
        Effect2.fromNullable(config.scripts.get(stakeCredential.hash)),
        Effect2.orElseFail(
          () => txBuilderError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      const addPlutusCertificate = (scriptVersion) => {
        return Effect2.gen(function* () {
          const red = yield* pipe(
            Effect2.fromNullable(redeemer),
            Effect2.orElseFail(
              () => txBuilderError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(scriptVersion, red),
              CML2.Ed25519KeyHashList.new()
            )
          );
        });
      };
      switch (script.type) {
        case "PlutusV1":
          yield* addPlutusCertificate(toV1(script.script));
          break;
        case "PlutusV2":
          yield* addPlutusCertificate(toV2(script.script));
          break;
        case "PlutusV3":
          yield* addPlutusCertificate(toV3(script.script));
          break;
        case "Native":
          config.txBuilder.add_cert(
            certBuilder.native_script(
              CML2.NativeScript.from_cbor_hex(script.script),
              CML2.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
      }
      break;
    }
  }
});
var validateAndGetStakeCredential = (rewardAddress, config) => Effect2.gen(function* () {
  const addressDetails = yield* pipe(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect2.andThen(
      (address) => address.type !== "Reward" ? txBuilderError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : Effect2.succeed(address)
    )
  );
  const stakeCredential = yield* pipe(
    Effect2.fromNullable(addressDetails.stakeCredential),
    Effect2.orElseFail(
      () => txBuilderError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  return stakeCredential;
});
var resolveDatum = (datumHash, datum, provider) => Effect2.gen(function* () {
  if (!datumHash || datum) return datum;
  return yield* pipe(
    Effect2.tryPromise({
      try: () => provider.getDatum(datumHash),
      catch: txBuilderError
    }),
    Effect2.map(Data3.to)
  );
});

// src/tx-builder/internal/Collect.ts
import { paymentCredentialOf } from "@lucid-evolution/utils";

// src/tx-builder/internal/Service.ts
import { Context } from "effect";
var TxConfig = class extends Context.Tag("TxConfig")() {
};

// src/tx-builder/internal/Collect.ts
var collectError = (cause) => new TxBuilderError({ cause: `{ Collect: ${cause} }` });
var collectFromUTxO = (utxos, collectInputs = true) => (redeemer) => Effect4.gen(function* () {
  const { config } = yield* TxConfig;
  if (utxos.length === 0) yield* collectError(ERROR_MESSAGE.EMPTY_UTXO);
  for (const utxo of utxos) {
    const resolvedDatum = yield* resolveDatum(
      utxo.datumHash,
      utxo.datum,
      config.lucidConfig.provider
    );
    if (collectInputs) config.collectedInputs.push(utxo);
    const input = CML3.SingleInputBuilder.from_transaction_unspent_output(
      utxoToCore({ ...utxo, datum: resolvedDatum })
    );
    const credential = paymentCredentialOf(utxo.address);
    if (credential.type == "Script") {
      const script = yield* pipe2(
        Effect4.fromNullable(config.scripts.get(credential.hash)),
        Effect4.orElseFail(
          () => collectError(
            collectError(ERROR_MESSAGE.MISSING_SCRIPT(credential.hash))
          )
        )
      );
      switch (script.type) {
        case "Native":
          config.txBuilder.add_input(
            input.native_script(
              CML3.NativeScript.from_cbor_hex(script.script),
              CML3.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        case "PlutusV1": {
          const red = yield* pipe2(
            Effect4.fromNullable(redeemer),
            Effect4.orElseFail(
              () => collectError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          config.txBuilder.add_input(
            input.plutus_script(
              toPartial(toV1(script.script), red),
              CML3.Ed25519KeyHashList.new(),
              CML3.PlutusData.from_cbor_hex(utxo.datum)
            )
          );
          break;
        }
        case "PlutusV2": {
          const v2 = toV2(script.script);
          const red = yield* pipe2(
            Effect4.fromNullable(redeemer),
            Effect4.orElseFail(
              () => collectError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          const partial = toPartial(v2, red);
          config.txBuilder.add_input(
            utxo.datum && utxo.datumHash ? input.plutus_script(
              partial,
              CML3.Ed25519KeyHashList.new(),
              CML3.PlutusData.from_cbor_hex(utxo.datum)
            ) : input.plutus_script_inline_datum(
              partial,
              CML3.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const v3 = toV3(script.script);
          const red = yield* pipe2(
            Effect4.fromNullable(redeemer),
            Effect4.orElseFail(
              () => collectError(ERROR_MESSAGE.MISSING_REDEEMER)
            )
          );
          const partial = toPartial(v3, red);
          config.txBuilder.add_input(
            utxo.datum && utxo.datumHash ? input.plutus_script(
              partial,
              CML3.Ed25519KeyHashList.new(),
              CML3.PlutusData.from_cbor_hex(utxo.datum)
            ) : input.plutus_script_inline_datum(
              partial,
              CML3.Ed25519KeyHashList.new()
            )
          );
          break;
        }
      }
    } else {
      config.txBuilder.add_input(input.payment_key());
    }
  }
});
var collectFromUTxOPartial = (utxos, redeemerBuilder) => Effect4.gen(function* () {
  const { config } = yield* TxConfig;
  if (utxos.length === 0) yield* collectError(ERROR_MESSAGE.EMPTY_UTXO);
  if (redeemerBuilder.kind === "self") redeemerBuilder.inputs = utxos;
  for (const utxo of utxos) {
    if (utxo.datumHash && !utxo.datum) {
      const data = yield* Effect4.tryPromise({
        try: () => datumOf(config.lucidConfig.provider, utxo),
        catch: (cause) => collectError({ cause })
      });
      utxo.datum = Data4.to(data);
    }
    config.collectedInputs.push(utxo);
  }
  const partialProgram = collectFromUTxO(utxos, false);
  config.partialPrograms.set(redeemerBuilder, partialProgram);
});

// src/tx-builder/internal/Read.ts
import { Effect as Effect5 } from "effect";
import { utxoToCore as utxoToCore2 } from "@lucid-evolution/utils";
var readError = (cause) => new TxBuilderError({ cause: `{ Read : ${cause} }` });
var readFrom = (utxos) => Effect5.gen(function* () {
  const { config } = yield* TxConfig;
  if (utxos.length === 0) yield* readError(ERROR_MESSAGE.EMPTY_UTXO);
  for (const utxo of utxos) {
    const resolvedDatum = yield* resolveDatum(
      utxo.datumHash,
      utxo.datum,
      config.lucidConfig.provider
    );
    const coreUtxo = utxoToCore2({ ...utxo, datum: resolvedDatum });
    const exists = config.readInputs.some(
      (input) => input.txHash === utxo.txHash && input.outputIndex === utxo.outputIndex
    );
    if (!exists) {
      config.txBuilder.add_reference_input(coreUtxo);
      config.readInputs.push(utxo);
    }
  }
});

// src/tx-builder/internal/Attach.ts
import { applyDoubleCborEncoding } from "@lucid-evolution/utils";
var attachScript = ({ type, script }) => {
  switch (type) {
    case "Native":
      return {
        key: CML.NativeScript.from_cbor_hex(script).hash().to_hex(),
        value: { type, script }
      };
    case "PlutusV1":
      return {
        key: CML.PlutusV1Script.from_cbor_hex(applyDoubleCborEncoding(script)).hash().to_hex(),
        value: { type, script: applyDoubleCborEncoding(script) }
      };
    case "PlutusV2":
      return {
        key: CML.PlutusV2Script.from_cbor_hex(applyDoubleCborEncoding(script)).hash().to_hex(),
        value: { type, script: applyDoubleCborEncoding(script) }
      };
    case "PlutusV3":
      return {
        key: CML.PlutusV3Script.from_cbor_hex(applyDoubleCborEncoding(script)).hash().to_hex(),
        value: { type, script: applyDoubleCborEncoding(script) }
      };
    default:
      throw new Error(`Exhaustive check failed: Unhandled case ${type}`);
  }
};
var attachSpendingValidator = (spendingValidator) => attachScript(spendingValidator);
var attachMintingPolicy = (mintingPolicy) => attachScript(mintingPolicy);
var attachCertificateValidator = (certValidator) => attachScript(certValidator);
var attachWithdrawalValidator = (withdrawalValidator) => attachScript(withdrawalValidator);
var attachVoteValidator = (voteValidator) => attachScript(voteValidator);
var attachProposeValidator = (proposeValidator) => attachScript(proposeValidator);

// src/tx-builder/internal/Pay.ts
import { Effect as Effect6 } from "effect";
import {
  addAssets,
  assetsToValue,
  coreToTxOutput,
  toScriptRef,
  valueToAssets
} from "@lucid-evolution/utils";
var payError = (cause) => new TxBuilderError({ cause: `{ Pay: ${cause} }` });
var payToAddress = (address, assets) => Effect6.gen(function* () {
  const { config } = yield* TxConfig;
  const outputBuilder = CML.TransactionOutputBuilder.new().with_address(yield* toCMLAddress(address, config.lucidConfig)).next();
  if (Object.keys(assets).length == 0)
    yield* payError(ERROR_MESSAGE.EMPTY_ASSETS);
  const value = assetsToValue(assets);
  let outputResult = outputBuilder.with_asset_and_min_required_coin(
    value.multi_asset(),
    config.lucidConfig.protocolParameters.coinsPerUtxoByte
  ).build();
  const setLovelaces = assets["lovelace"];
  if (setLovelaces) {
    const minLovelace = outputResult.output().amount().coin();
    if (setLovelaces > minLovelace) {
      outputResult = outputBuilder.with_value(value).build();
    }
  }
  config.totalOutputAssets = addAssets(
    config.totalOutputAssets,
    valueToAssets(outputResult.output().amount())
  );
  config.payToOutputs = [
    ...config.payToOutputs,
    coreToTxOutput(outputResult.output())
  ];
  config.txBuilder.add_output(outputResult);
});
var ToAddressWithData = (address, outputDatum, assets, scriptRef) => Effect6.gen(function* () {
  const { config } = yield* TxConfig;
  const outputBuilder = buildBaseOutput(address, outputDatum, scriptRef);
  assets ??= {};
  const value = assetsToValue(assets);
  let outputResult = outputBuilder.with_asset_and_min_required_coin(
    value.multi_asset(),
    config.lucidConfig.protocolParameters.coinsPerUtxoByte
  ).build();
  const setLovelaces = assets["lovelace"];
  if (setLovelaces) {
    const minLovelace = outputResult.output().amount().coin();
    if (setLovelaces > minLovelace) {
      outputResult = outputBuilder.with_value(value).build();
    }
  }
  config.totalOutputAssets = addAssets(
    config.totalOutputAssets,
    valueToAssets(outputResult.output().amount())
  );
  config.payToOutputs = [
    ...config.payToOutputs,
    coreToTxOutput(outputResult.output())
  ];
  config.txBuilder.add_output(outputResult);
});
var ToContract = (address, outputDatum, assets, scriptRef) => ToAddressWithData(address, outputDatum, assets, scriptRef);
var buildBaseOutput = (address, outputDatum, scriptRef) => {
  let baseBuilder;
  const addressBuilder = CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(address)
  );
  if (outputDatum) {
    if (outputDatum.value.trim() === "") {
      throw new Error(
        "datum value is missing. Please provide a non-empty cbor hex data."
      );
    }
    switch (outputDatum.kind) {
      case "hash": {
        const datumOption = CML.DatumOption.new_hash(
          CML.DatumHash.from_hex(outputDatum.value)
        );
        baseBuilder = addressBuilder.with_data(datumOption);
        break;
      }
      case "asHash": {
        const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
        baseBuilder = addressBuilder.with_communication_data(plutusData);
        break;
      }
      case "inline": {
        const plutusData = CML.PlutusData.from_cbor_hex(outputDatum.value);
        const datumOption = CML.DatumOption.new_datum(plutusData);
        baseBuilder = addressBuilder.with_data(datumOption);
        break;
      }
      default:
        throw new Error(`Unknown outputDatum: ${outputDatum}`);
    }
  } else {
    baseBuilder = addressBuilder;
  }
  return scriptRef ? baseBuilder.with_reference_script(toScriptRef(scriptRef)).next() : baseBuilder.next();
};

// src/tx-builder/internal/Mint.ts
import { Effect as Effect7, pipe as pipe3 } from "effect";
import * as CML4 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
var mintError = (cause) => new TxBuilderError({ cause: `{ Mint: ${cause} }` });
var mintAssets = (assets) => (redeemer) => Effect7.gen(function* () {
  const { config } = yield* TxConfig;
  const units = Object.keys(assets);
  const policyId = units[0].slice(0, 56);
  const mintAssets2 = CML4.MapAssetNameToNonZeroInt64.new();
  for (const unit of units) {
    if (unit.slice(0, 56) !== policyId) {
      yield* mintError(ERROR_MESSAGE.MULTIPLE_POLICIES);
    }
    mintAssets2.insert(CML4.AssetName.from_hex(unit.slice(56)), assets[unit]);
  }
  const mintBuilder = CML4.SingleMintBuilder.new(mintAssets2);
  const policy = yield* pipe3(
    Effect7.fromNullable(config.scripts.get(policyId)),
    Effect7.orElseFail(
      () => mintError(ERROR_MESSAGE.MISSING_POLICY(policyId))
    )
  );
  switch (policy.type) {
    case "Native":
      config.txBuilder.add_mint(
        mintBuilder.native_script(
          CML4.NativeScript.from_cbor_hex(policy.script),
          CML4.NativeScriptWitnessInfo.assume_signature_count()
        )
      );
      break;
    case "PlutusV1": {
      const red = yield* pipe3(
        Effect7.fromNullable(redeemer),
        Effect7.orElseFail(() => mintError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV1(policy.script), red),
          CML4.Ed25519KeyHashList.new()
        )
      );
      break;
    }
    case "PlutusV2": {
      const red = yield* pipe3(
        Effect7.fromNullable(redeemer),
        Effect7.orElseFail(() => mintError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV2(policy.script), red),
          CML4.Ed25519KeyHashList.new()
        )
      );
      break;
    }
    case "PlutusV3": {
      const red = yield* pipe3(
        Effect7.fromNullable(redeemer),
        Effect7.orElseFail(() => mintError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      config.txBuilder.add_mint(
        mintBuilder.plutus_script(
          toPartial(toV3(policy.script), red),
          CML4.Ed25519KeyHashList.new()
        )
      );
      break;
    }
  }
});

// src/tx-builder/internal/Interval.ts
import { Effect as Effect8 } from "effect";
import { unixTimeToSlot } from "@lucid-evolution/utils";
var validFrom = (unixTime) => Effect8.gen(function* () {
  const { config } = yield* TxConfig;
  const slot = unixTimeToSlot(config.lucidConfig.network, unixTime);
  config.txBuilder.set_validity_start_interval(BigInt(slot));
});
var validTo = (unixTime) => Effect8.gen(function* () {
  const { config } = yield* TxConfig;
  const slot = unixTimeToSlot(config.lucidConfig.network, unixTime);
  config.txBuilder.set_ttl(BigInt(slot));
});

// src/tx-builder/internal/Signer.ts
import { Effect as Effect9, pipe as pipe4 } from "effect";
import * as CML5 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
var addSignerError = (cause) => new TxBuilderError({ cause: `{ Signer: ${cause} }` });
var addSigner = (address) => Effect9.gen(function* () {
  const { config } = yield* TxConfig;
  const addressDetails = yield* validateAddressDetails(
    address,
    config.lucidConfig
  );
  const credential = addressDetails.type === "Reward" ? yield* pipe4(
    Effect9.fromNullable(addressDetails.stakeCredential),
    Effect9.orElseFail(
      () => addSignerError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  ) : yield* pipe4(
    Effect9.fromNullable(addressDetails.paymentCredential),
    Effect9.orElseFail(
      () => addSignerError(ERROR_MESSAGE.MISSING_PAYMENT_CREDENTIAL)
    )
  );
  if (credential.type === "Script")
    yield* addSignerError(ERROR_MESSAGE.SCRIPT_CREDENTIAL_NOT_ALLOWED);
  return credential.hash;
}).pipe(Effect9.flatMap((keyHash) => addSignerKey(keyHash)));
var addSignerKey = (keyHash) => Effect9.gen(function* () {
  const { config } = yield* TxConfig;
  config.txBuilder.add_required_signer(CML5.Ed25519KeyHash.from_hex(keyHash));
});

// src/tx-builder/internal/Stake.ts
import { Effect as Effect10, pipe as pipe5 } from "effect";
import * as CML6 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
var stakeError = (cause) => new TxBuilderError({ cause: `{ Stake: ${cause} }` });
var registerStake = (rewardAddress) => Effect10.gen(function* () {
  const { config } = yield* TxConfig;
  const addressDetails = yield* pipe5(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect10.andThen(
      (address) => address.type !== "Reward" ? stakeError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : Effect10.succeed(address)
    )
  );
  const stakeCredential = yield* pipe5(
    Effect10.fromNullable(addressDetails.stakeCredential),
    Effect10.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  const credential = stakeCredential.type === "Key" ? CML6.Credential.new_pub_key(
    CML6.Ed25519KeyHash.from_hex(stakeCredential.hash)
  ) : CML6.Credential.new_script(
    CML6.ScriptHash.from_hex(stakeCredential.hash)
  );
  const certBuilder = CML6.SingleCertificateBuilder.new(
    CML6.Certificate.new_stake_registration(credential)
  );
  config.txBuilder.add_cert(certBuilder.skip_witness());
});
var deRegisterStake = (rewardAddress, redeemer) => Effect10.gen(function* () {
  const { config } = yield* TxConfig;
  const addressDetails = yield* pipe5(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect10.andThen(
      (address) => address.type !== "Reward" ? stakeError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : Effect10.succeed(address)
    )
  );
  const stakeCredential = yield* pipe5(
    Effect10.fromNullable(addressDetails.stakeCredential),
    Effect10.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  const createCertBuilder = (credential, config2) => {
    return CML6.SingleCertificateBuilder.new(
      CML6.Certificate.new_unreg_cert(
        credential,
        config2.lucidConfig.protocolParameters.keyDeposit
      )
    );
  };
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML6.Credential.new_pub_key(
        CML6.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = createCertBuilder(credential, config);
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML6.Credential.new_script(
        CML6.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = createCertBuilder(credential, config);
      const script = yield* pipe5(
        Effect10.fromNullable(config.scripts.get(stakeCredential.hash)),
        Effect10.orElseFail(
          () => stakeError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      const handleRedeemer = () => pipe5(
        Effect10.fromNullable(redeemer),
        Effect10.orElseFail(() => stakeError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      switch (script.type) {
        case "PlutusV1": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV3(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          config.txBuilder.add_cert(
            certBuilder.native_script(
              CML6.NativeScript.from_cbor_hex(script.script),
              CML6.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        }
      }
    }
  }
});
var withdraw = (rewardAddress, amount) => (redeemer) => Effect10.gen(function* () {
  const { config } = yield* TxConfig;
  const addressDetails = yield* pipe5(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect10.andThen(
      (address) => address.type !== "Reward" ? stakeError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : Effect10.succeed(address)
    )
  );
  const withdrawBuilder = yield* pipe5(
    Effect10.fromNullable(
      CML6.RewardAddress.from_address(
        CML6.Address.from_bech32(rewardAddress)
      )
    ),
    Effect10.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    ),
    Effect10.andThen(
      (address) => CML6.SingleWithdrawalBuilder.new(address, amount)
    )
  );
  const stakeCredential = yield* pipe5(
    Effect10.fromNullable(addressDetails.stakeCredential),
    Effect10.orElseFail(
      () => stakeError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  const handleRedeemer = () => pipe5(
    Effect10.fromNullable(redeemer),
    Effect10.orElseFail(() => stakeError(ERROR_MESSAGE.MISSING_REDEEMER))
  );
  switch (stakeCredential.type) {
    case "Key": {
      config.txBuilder.add_withdrawal(withdrawBuilder.payment_key());
      break;
    }
    case "Script": {
      const script = yield* pipe5(
        Effect10.fromNullable(config.scripts.get(stakeCredential.hash)),
        Effect10.orElseFail(
          () => stakeError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      switch (script.type) {
        case "PlutusV1": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_withdrawal(
            withdrawBuilder.plutus_script(
              toPartial(toV3(script.script), red),
              CML6.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          config.txBuilder.add_withdrawal(
            withdrawBuilder.native_script(
              CML6.NativeScript.from_cbor_hex(script.script),
              CML6.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Pool.ts
import { Effect as Effect11, pipe as pipe6 } from "effect";
import * as CML7 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
import { fromText } from "@lucid-evolution/core-utils";
var poolError = (cause) => new TxBuilderError({ cause: `{ Pool : ${cause} }` });
var delegateTo = (rewardAddress, poolId, redeemer) => Effect11.gen(function* () {
  const { config } = yield* TxConfig;
  const addressDetails = yield* pipe6(
    validateAddressDetails(rewardAddress, config.lucidConfig),
    Effect11.andThen(
      (address) => address.type !== "Reward" ? poolError(ERROR_MESSAGE.MISSING_REWARD_TYPE) : Effect11.succeed(address)
    )
  );
  const stakeCredential = yield* pipe6(
    Effect11.fromNullable(addressDetails.stakeCredential),
    Effect11.orElseFail(
      () => poolError(ERROR_MESSAGE.MISSING_STAKE_CREDENTIAL)
    )
  );
  switch (stakeCredential.type) {
    case "Key": {
      const credential = CML7.Credential.new_pub_key(
        CML7.Ed25519KeyHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML7.SingleCertificateBuilder.new(
        CML7.Certificate.new_stake_delegation(
          credential,
          CML7.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      config.txBuilder.add_cert(certBuilder.payment_key());
      break;
    }
    case "Script": {
      const credential = CML7.Credential.new_script(
        CML7.ScriptHash.from_hex(stakeCredential.hash)
      );
      const certBuilder = CML7.SingleCertificateBuilder.new(
        CML7.Certificate.new_stake_delegation(
          credential,
          CML7.Ed25519KeyHash.from_bech32(poolId)
        )
      );
      const script = yield* pipe6(
        Effect11.fromNullable(config.scripts.get(stakeCredential.hash)),
        Effect11.orElseFail(
          () => poolError(ERROR_MESSAGE.MISSING_SCRIPT(stakeCredential.hash))
        )
      );
      const handleRedeemer = () => pipe6(
        Effect11.fromNullable(redeemer),
        Effect11.orElseFail(() => poolError(ERROR_MESSAGE.MISSING_REDEEMER))
      );
      switch (script.type) {
        case "PlutusV1": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV1(script.script), red),
              CML7.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV2": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV2(script.script), red),
              CML7.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "PlutusV3": {
          const red = yield* handleRedeemer();
          config.txBuilder.add_cert(
            certBuilder.plutus_script(
              toPartial(toV3(script.script), red),
              CML7.Ed25519KeyHashList.new()
            )
          );
          break;
        }
        case "Native": {
          config.txBuilder.add_cert(
            certBuilder.native_script(
              CML7.NativeScript.from_cbor_hex(script.script),
              CML7.NativeScriptWitnessInfo.assume_signature_count()
            )
          );
          break;
        }
      }
    }
  }
});

// src/tx-builder/internal/Governance.ts
import * as CML8 from "@anastasia-labs/cardano-multiplatform-lib-nodejs";
import { Effect as Effect12 } from "effect";
var isDRepCredential = (deleg) => !("__typename" in deleg);
var isDRepAlwaysAbstain = (deleg) => !isDRepCredential(deleg) && deleg.__typename === "AlwaysAbstain";
var isDRepAlwaysNoConfidence = (deleg) => !isDRepCredential(deleg) && deleg.__typename === "AlwaysNoConfidence";
var toCMLDRep = (drep) => {
  if (isDRepAlwaysAbstain(drep)) {
    return CML8.DRep.new_always_abstain();
  } else if (isDRepAlwaysNoConfidence(drep)) {
    return CML8.DRep.new_always_no_confidence();
  } else if (isDRepCredential(drep)) {
    switch (drep.type) {
      case "Key":
        return CML8.DRep.new_key(CML8.Ed25519KeyHash.from_hex(drep.hash));
      case "Script":
        return CML8.DRep.new_script(CML8.ScriptHash.from_hex(drep.hash));
      default:
        throw new Error(`Unsupported DRep type: ${drep.type}`);
    }
  }
  throw new Error(`Unexpected DRep type: ${drep}`);
};
var delegateVoteToDRep = (rewardAddress, drep, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = toCMLDRep(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_vote_deleg_cert(credential, cmlDRep)
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var delegateVoteToPoolAndDRep = (rewardAddress, poolId, drep, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = toCMLDRep(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_stake_vote_deleg_cert(
      credential,
      CML8.Ed25519KeyHash.from_bech32(poolId),
      cmlDRep
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerAndDelegateToPool = (rewardAddress, poolId, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_stake_reg_deleg_cert(
      credential,
      CML8.Ed25519KeyHash.from_bech32(poolId),
      config.lucidConfig.protocolParameters.keyDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerAndDelegateToDRep = (rewardAddress, drep, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = toCMLDRep(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_vote_reg_deleg_cert(
      credential,
      cmlDRep,
      config.lucidConfig.protocolParameters.keyDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerAndDelegateToPoolAndDRep = (rewardAddress, poolId, drep, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlDRep = toCMLDRep(drep);
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_stake_vote_reg_deleg_cert(
      credential,
      CML8.Ed25519KeyHash.from_bech32(poolId),
      cmlDRep,
      config.lucidConfig.protocolParameters.keyDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var registerDRep = (rewardAddress, anchor, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlAnchor = anchor ? CML8.Anchor.new(
    CML8.Url.from_json(anchor.url),
    CML8.AnchorDocHash.from_hex(anchor.dataHash)
  ) : void 0;
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_reg_drep_cert(
      credential,
      config.lucidConfig.protocolParameters.drepDeposit,
      cmlAnchor
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var deregisterDRep = (rewardAddress, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_unreg_drep_cert(
      credential,
      config.lucidConfig.protocolParameters.drepDeposit
    )
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var updateDRep = (rewardAddress, anchor, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const stakeCredential = yield* validateAndGetStakeCredential(
    rewardAddress,
    config
  );
  const cmlAnchor = anchor ? CML8.Anchor.new(
    CML8.Url.from_json(anchor.url),
    CML8.AnchorDocHash.from_hex(anchor.dataHash)
  ) : void 0;
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_update_drep_cert(credential, cmlAnchor)
  );
  yield* processCertificate(stakeCredential, config, buildCert, redeemer);
});
var authCommitteeHot = (coldAddress, hotAddress, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const coldCred = yield* validateAndGetStakeCredential(coldAddress, config);
  const hotCred = yield* validateAndGetStakeCredential(hotAddress, config);
  const hotCredential = hotCred.type === "Key" ? CML8.Credential.new_pub_key(CML8.Ed25519KeyHash.from_hex(hotCred.hash)) : CML8.Credential.new_script(CML8.ScriptHash.from_hex(hotCred.hash));
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_auth_committee_hot_cert(credential, hotCredential)
  );
  yield* processCertificate(coldCred, config, buildCert, redeemer);
});
var resignCommitteeHot = (coldAddress, anchor, redeemer) => Effect12.gen(function* () {
  const { config } = yield* TxConfig;
  const coldCred = yield* validateAndGetStakeCredential(coldAddress, config);
  const cmlAnchor = anchor ? CML8.Anchor.new(
    CML8.Url.from_json(anchor.url),
    CML8.AnchorDocHash.from_hex(anchor.dataHash)
  ) : void 0;
  const buildCert = (credential) => CML8.SingleCertificateBuilder.new(
    CML8.Certificate.new_resign_committee_cold_cert(credential, cmlAnchor)
  );
  yield* processCertificate(coldCred, config, buildCert, redeemer);
});

// src/tx-builder/internal/Metadata.ts
import { Effect as Effect13 } from "effect";
import * as S from "@effect/schema/Schema";
import { toHex } from "@lucid-evolution/core-utils";
var attachMetadata = (config, label, metadata) => Effect13.gen(function* () {
  const auxiliaryData = CML.AuxiliaryData.new();
  const meta = CML.Metadata.new();
  meta.set(
    BigInt(label),
    CML.TransactionMetadatum.from_json(
      JSON.stringify(toCardanoMetadata(metadata))
    )
  );
  auxiliaryData.add_metadata(meta);
  config.txBuilder.add_auxiliary_data(auxiliaryData);
  auxiliaryData.free();
  meta.free();
});
var TextSchema = S.String.pipe(S.maxLength(64));
var TransactionMetadataSchema = S.Union(
  TextSchema,
  S.Number,
  S.Uint8ArrayFromSelf,
  S.Array(S.suspend(() => TransactionMetadataSchema)),
  S.Record(
    S.String,
    S.suspend(() => TransactionMetadataSchema)
  )
);
var toCardanoMetadata = (json) => {
  const d = S.asserts(TransactionMetadataSchema)(json);
  if (S.is(TextSchema)(json)) {
    return { string: json };
  }
  if (typeof json === "number") {
    return { int: json };
  }
  if (json instanceof Uint8Array) {
    return { bytes: toHex(json) };
  }
  if (Array.isArray(json)) {
    return { list: json.map((value) => toCardanoMetadata(value)) };
  }
  if (typeof json === "object" && json !== null) {
    const mapEntries = Object.entries(json).map(([k, v]) => ({
      k: toCardanoMetadata(k),
      v: toCardanoMetadata(v)
    }));
    return { map: mapEntries };
  }
  throw new Error("Unsupported type");
};

// src/tx-builder/internal/CompleteTxBuilder.ts
import {
  Effect as Effect17,
  pipe as pipe9,
  Record as Record2,
  Array as _Array,
  BigInt as _BigInt,
  Tuple,
  Option
} from "effect";
import * as UPLC from "@lucid-evolution/uplc";

// src/tx-sign-builder/TxSignBuilder.ts
import * as S3 from "@effect/schema/Schema";

// src/tx-sign-builder/internal/CompleteTxSigner.ts
import { Effect as Effect16, pipe as pipe8 } from "effect";

// src/tx-submit/TxSubmit.ts
import { Effect as Effect14 } from "effect";
import * as S2 from "@effect/schema/Schema";
var makeSubmit = (wallet, txSigned) => {
  const submit = (options) => Effect14.tryPromise({
    try: () => wallet.submitTx(
      options.canonical ? txSigned.to_canonical_cbor_hex() : txSigned.to_cbor_hex()
    ),
    catch: (cause) => new TxSubmitError({ cause })
  });
  return {
    submit: (options = { canonical: false }) => makeReturn(submit(options)).unsafeRun(),
    submitProgram: (options = { canonical: false }) => submit(options),
    submitSafe: (options = { canonical: false }) => makeReturn(submit(options)).safeRun(),
    toCBOR: (options = { canonical: false }) => options.canonical ? txSigned.to_canonical_cbor_hex() : txSigned.to_cbor_hex(),
    toTransaction: () => txSigned,
    toJSON: () => S2.decodeUnknownSync(S2.parseJson(S2.Object))(txSigned.to_json()),
    toHash: () => CML.hash_transaction(txSigned.body()).to_hex()
  };
};

// src/tx-sign-builder/internal/Sign.ts
import { Effect as Effect15, pipe as pipe7 } from "effect";
var signError = (cause) => new TxSignerError({ cause });
var mkWitnessFromWallet = (wallet, txComplete) => pipe7(
  Effect15.fromNullable(wallet),
  Effect15.catchAll(() => signError(ERROR_MESSAGE.MISSING_WALLET)),
  Effect15.tryMapPromise({
    try: (wallet2) => wallet2.signTx(txComplete),
    catch: (cause) => signError(cause)
  })
);
var withWallet = (config) => pipe7(
  mkWitnessFromWallet(config.wallet, config.txComplete),
  Effect15.map((witness) => config.witnessSetBuilder.add_existing(witness))
);
var partialWithWallet = (config) => pipe7(
  mkWitnessFromWallet(config.wallet, config.txComplete),
  Effect15.map((witness) => witness.to_cbor_hex())
);
var mkWitnessFromPrivateKey = (privateKey, txComplete) => pipe7(
  Effect15.try({
    try: () => CML.PrivateKey.from_bech32(privateKey),
    catch: signError
  }),
  Effect15.map(
    (privateKey2) => CML.make_vkey_witness(
      CML.hash_transaction(txComplete.body()),
      privateKey2
    )
  )
);
var withPrivateKey = (config, privateKey) => pipe7(
  mkWitnessFromPrivateKey(privateKey, config.txComplete),
  Effect15.map((witness) => config.witnessSetBuilder.add_vkey(witness))
);
var partialWithPrivateKey = (config, privateKey) => pipe7(
  mkWitnessFromPrivateKey(privateKey, config.txComplete),
  Effect15.map((witness) => {
    const witnessBuilder = CML.TransactionWitnessSetBuilder.new();
    witnessBuilder.add_vkey(witness);
    return witnessBuilder.build().to_cbor_hex();
  })
);
var assemble = (config, witnesses) => Effect15.forEach(
  witnesses,
  (witness) => pipe7(
    Effect15.try({
      try: () => CML.TransactionWitnessSet.from_cbor_hex(witness),
      catch: signError
    }),
    Effect15.map((witness2) => config.witnessSetBuilder.add_existing(witness2))
  )
);

// src/tx-sign-builder/internal/CompleteTxSigner.ts
var completeTxSigner = (config) => Effect16.gen(function* () {
  yield* Effect16.all(config.programs, { concurrency: "unbounded" });
  const plutus_datums = config.txComplete.witness_set().plutus_datums();
  config.witnessSetBuilder.add_existing(config.txComplete.witness_set());
  if (plutus_datums) {
    for (let i = 0; i < plutus_datums.len(); i++) {
      config.witnessSetBuilder.add_plutus_datum(plutus_datums.get(i));
    }
  }
  const txWitnessSet = config.witnessSetBuilder.build();
  const signedTx = CML.Transaction.new(
    config.txComplete.body(),
    txWitnessSet,
    true,
    config.txComplete.auxiliary_data()
  );
  const wallet = yield* pipe8(
    Effect16.fromNullable(config.wallet),
    Effect16.orElseFail(() => signError(ERROR_MESSAGE.MISSING_WALLET))
  );
  return makeSubmit(wallet, signedTx);
}).pipe(Effect16.catchAllDefect((cause) => new RunTimeError({ cause })));

// src/tx-sign-builder/TxSignBuilder.ts
var makeTxSignBuilder = (wallet, tx) => {
  const redeemers = tx.witness_set().redeemers();
  const exUnits = { cpu: 0, mem: 0 };
  if (redeemers) {
    const arrLegacyRedeemer = redeemers?.as_arr_legacy_redeemer();
    if (arrLegacyRedeemer) {
      for (let i = 0; i < arrLegacyRedeemer.len(); i++) {
        const redeemer = arrLegacyRedeemer.get(i);
        exUnits.cpu += parseInt(redeemer.ex_units().steps().toString());
        exUnits.mem += parseInt(redeemer.ex_units().mem().toString());
      }
    }
    const mapRedeemerKeyToRedeemerVal = redeemers?.as_map_redeemer_key_to_redeemer_val();
    if (mapRedeemerKeyToRedeemerVal) {
      const keys = mapRedeemerKeyToRedeemerVal.keys();
      for (let i = 0; i < (keys.len() || 0); i++) {
        const key = keys.get(i);
        const value = mapRedeemerKeyToRedeemerVal.get(key);
        exUnits.cpu += parseInt(value.ex_units().steps().toString());
        exUnits.mem += parseInt(value.ex_units().mem().toString());
      }
    }
  }
  const config = {
    txComplete: tx,
    witnessSetBuilder: CML.TransactionWitnessSetBuilder.new(),
    programs: [],
    wallet,
    fee: parseInt(tx.body().fee().toString()),
    exUnits
  };
  const txSignBuilder = {
    sign: {
      withWallet: () => {
        const program = withWallet(config);
        config.programs.push(program);
        return txSignBuilder;
      },
      withPrivateKey: (privateKey) => {
        const program = withPrivateKey(config, privateKey);
        config.programs.push(program);
        return txSignBuilder;
      }
    },
    partialSign: {
      withWallet: () => makeReturn(partialWithWallet(config)).unsafeRun(),
      withWalletEffect: () => partialWithWallet(config),
      withWalletSafe: () => makeReturn(partialWithWallet(config)).safeRun(),
      withPrivateKey: (privateKey) => makeReturn(partialWithPrivateKey(config, privateKey)).unsafeRun(),
      withPrivateKeyEffect: (privateKey) => partialWithPrivateKey(config, privateKey),
      withPrivateKeySafe: (privateKey) => makeReturn(partialWithPrivateKey(config, privateKey)).safeRun()
    },
    assemble: (witnesses) => {
      const program = assemble(config, witnesses);
      config.programs.push(program);
      return txSignBuilder;
    },
    toCBOR: (options = { canonical: false }) => options.canonical ? config.txComplete.to_canonical_cbor_hex() : config.txComplete.to_cbor_hex(),
    toTransaction: () => config.txComplete,
    toJSON: () => S3.decodeUnknownSync(S3.parseJson(S3.Object))(config.txComplete.to_json()),
    toHash: () => CML.hash_transaction(config.txComplete.body()).to_hex(),
    complete: () => makeReturn(completeTxSigner(config)).unsafeRun(),
    completeProgram: () => completeTxSigner(config),
    completeSafe: () => makeReturn(completeTxSigner(config)).safeRun()
  };
  return txSignBuilder;
};

// src/tx-builder/internal/CompleteTxBuilder.ts
import {
  assetsToValue as assetsToValue2,
  coreToTxOutput as coreToTxOutput2,
  isEqualUTxO,
  selectUTxOs,
  sortUTxOs,
  stringify,
  utxoToCore as utxoToCore3,
  utxoToTransactionInput,
  utxoToTransactionOutput,
  toCMLRedeemerTag
} from "@lucid-evolution/utils";
import { SLOT_CONFIG_NETWORK } from "@lucid-evolution/plutus";
import { isError } from "effect/Predicate";
var completeTxError = (cause) => new TxBuilderError({ cause: `{ Complete: ${cause} }` });
var complete = (options = {}) => Effect17.gen(function* () {
  const { config } = yield* TxConfig;
  const wallet = yield* pipe9(
    Effect17.fromNullable(config.lucidConfig.wallet),
    Effect17.orElseFail(() => completeTxError(ERROR_MESSAGE.MISSING_WALLET))
  );
  const walletAddress = yield* Effect17.promise(() => wallet.address());
  const {
    coinSelection = true,
    changeAddress = walletAddress,
    localUPLCEval = true,
    setCollateral = 5000000n,
    canonical = false,
    includeLeftoverLovelaceAsFee = false,
    presetWalletInputs = []
  } = options;
  const walletInputs = presetWalletInputs.length === 0 ? yield* Effect17.tryPromise({
    try: () => wallet.getUtxos(),
    catch: (error) => completeTxError(error)
  }) : presetWalletInputs;
  yield* Effect17.all(config.programs);
  const hasPlutusScriptExecutions = Array.from(
    config.scripts.values()
  ).some((value) => value.type !== "Native");
  yield* selectionAndEvaluation(
    walletInputs,
    changeAddress,
    coinSelection,
    localUPLCEval,
    includeLeftoverLovelaceAsFee,
    false
  );
  if (hasPlutusScriptExecutions) {
    const minFee = config.txBuilder.min_fee(true);
    const refScriptFee = yield* calculateMinRefScriptFee(config);
    let estimatedFee = minFee + refScriptFee;
    const totalCollateral = BigInt(
      Math.ceil(
        Math.max(
          config.lucidConfig.protocolParameters.collateralPercentage * Number(estimatedFee) / 100,
          Number(setCollateral)
        )
      )
    );
    const collateralInput = yield* findCollateral(
      config.lucidConfig.protocolParameters.coinsPerUtxoByte,
      totalCollateral,
      walletInputs
    );
    yield* applyCollateral(totalCollateral, collateralInput, changeAddress);
    yield* selectionAndEvaluation(
      walletInputs,
      changeAddress,
      coinSelection,
      localUPLCEval,
      includeLeftoverLovelaceAsFee,
      true
    );
  }
  config.txBuilder.add_change_if_needed(
    CML.Address.from_bech32(changeAddress),
    true
  );
  const transaction = yield* Effect17.try({
    try: () => config.txBuilder.build(
      CML.ChangeSelectionAlgo.Default,
      CML.Address.from_bech32(changeAddress)
    ).build_unchecked(),
    catch: (error) => completeTxError(error)
  });
  const derivedInputs = deriveInputsFromTransaction(transaction);
  const derivedWalletInputs = derivedInputs.filter(
    (utxo) => utxo.address === walletAddress
  );
  const updatedWalletInputs = pipe9(
    _Array.differenceWith(isEqualUTxO)(walletInputs, config.consumedInputs),
    (availableWalletInputs) => [
      ...derivedWalletInputs,
      ...availableWalletInputs
    ]
  );
  return Tuple.make(
    updatedWalletInputs,
    derivedInputs,
    makeTxSignBuilder(
      config.lucidConfig.wallet,
      canonical ? CML.Transaction.from_cbor_bytes(
        transaction.to_canonical_cbor_bytes()
      ) : transaction
    )
  );
}).pipe(Effect17.catchAllDefect((cause) => new RunTimeError({ cause })));
var selectionAndEvaluation = (walletInputs, changeAddress, coinSelection, localUPLCEval, includeLeftoverLovelaceAsFee, script_calculation) => Effect17.gen(function* () {
  const { config } = yield* TxConfig;
  const refScriptInputs = config.readInputs.filter(
    (input) => input.scriptRef
  );
  const availableInputs = _Array.differenceWith(isEqualUTxO)(walletInputs, [
    ...config.collectedInputs,
    ...refScriptInputs
  ]);
  const { selected: inputsToAdd, burnable } = coinSelection !== false ? yield* doCoinSelection(
    config,
    availableInputs,
    script_calculation,
    includeLeftoverLovelaceAsFee
  ) : { selected: [], burnable: { lovelace: 0n } };
  let estimatedFee = 0n;
  if (_Array.isEmptyArray(inputsToAdd)) {
    if (script_calculation) return;
    estimatedFee += burnable.lovelace;
  }
  if (_Array.isNonEmptyArray(inputsToAdd)) {
    for (const utxo of inputsToAdd) {
      const input = CML.SingleInputBuilder.from_transaction_unspent_output(
        utxoToCore3(utxo)
      ).payment_key();
      config.txBuilder.add_input(input);
    }
    config.collectedInputs = [...config.collectedInputs, ...inputsToAdd];
    estimatedFee = yield* estimateFee(config, script_calculation);
  }
  config.consumedInputs = [...config.collectedInputs];
  if (config.partialPrograms.size > 0) {
    if (script_calculation) {
      yield* completeTxError(
        `RedeemerBuilder: Coin selection had to be updated after building redeemers, possibly leading to incorrect indices. Try setting a minimum fee of ${estimatedFee} lovelaces.`
      );
    } else yield* completePartialPrograms();
  }
  const txRedeemerBuilder = yield* Effect17.try({
    try: () => config.txBuilder.build_for_evaluation(
      0,
      CML.Address.from_bech32(changeAddress)
    ),
    catch: (error) => completeTxError(error)
  });
  if (txRedeemerBuilder.draft_tx().witness_set().redeemers()) {
    if (localUPLCEval !== false) {
      applyUPLCEval(
        yield* evalTransaction(config, txRedeemerBuilder, walletInputs),
        config.txBuilder
      );
    } else {
      applyUPLCEvalProvider(
        yield* evalTransactionProvider(
          config,
          txRedeemerBuilder,
          walletInputs
        ),
        config.txBuilder
      );
    }
  }
}).pipe(Effect17.catchAllDefect((cause) => new RunTimeError({ cause })));
var completePartialPrograms = () => Effect17.gen(function* () {
  const { config } = yield* TxConfig;
  const sortedInputs = sortUTxOs(config.collectedInputs, "Canonical");
  const indicesMap = /* @__PURE__ */ new Map();
  sortedInputs.forEach((value, index) => {
    indicesMap.set(value.txHash + value.outputIndex, BigInt(index));
  });
  const newPrograms = [];
  for (const [
    redeemerBuilder,
    partialProgram
  ] of config.partialPrograms.entries()) {
    if (redeemerBuilder.kind === "selected") {
      const inputIndices = redeemerBuilder.inputs.flatMap((value) => {
        const index = indicesMap.get(value.txHash + value.outputIndex);
        if (index !== void 0) return index;
        else return [];
      });
      if (_Array.isEmptyArray(inputIndices) || inputIndices.length !== redeemerBuilder.inputs.length)
        yield* completeTxError(
          `RedeemerBuilder: Missing indices for inputs: ${stringify(redeemerBuilder.inputs)}`
        );
      const redeemer = redeemerBuilder.makeRedeemer(inputIndices);
      const program = partialProgram(redeemer);
      newPrograms.push(program);
    } else {
      const inputs = yield* pipe9(
        Effect17.fromNullable(redeemerBuilder.inputs),
        Effect17.orElseFail(
          () => completeTxError(
            `RedeemerBuilder: Inputs for redeemer builder not founds: ${stringify(redeemerBuilder)}`
          )
        )
      );
      for (const input of inputs) {
        const index = yield* pipe9(
          Effect17.fromNullable(
            indicesMap.get(input.txHash + input.outputIndex)
          ),
          Effect17.orElseFail(
            () => completeTxError(`Index not found for input: ${input}`)
          )
        );
        const redeemer = redeemerBuilder.makeRedeemer(index);
        const program = collectFromUTxO([input], false)(redeemer);
        newPrograms.push(program);
      }
    }
  }
  yield* Effect17.all(newPrograms);
});
var applyUPLCEval = (uplcEval, txbuilder) => {
  for (const bytes of uplcEval) {
    const redeemer = CML.LegacyRedeemer.from_cbor_bytes(bytes);
    const exUnits = CML.ExUnits.new(
      redeemer.ex_units().mem(),
      redeemer.ex_units().steps()
    );
    txbuilder.set_exunits(
      CML.RedeemerWitnessKey.new(redeemer.tag(), redeemer.index()),
      exUnits
    );
  }
};
var applyUPLCEvalProvider = (evalRedeemerList, txbuilder) => {
  for (const evalRedeemer of evalRedeemerList) {
    const exUnits = CML.ExUnits.new(
      BigInt(evalRedeemer.ex_units.mem),
      BigInt(evalRedeemer.ex_units.steps)
    );
    txbuilder.set_exunits(
      CML.RedeemerWitnessKey.new(
        toCMLRedeemerTag(evalRedeemer.redeemer_tag),
        BigInt(evalRedeemer.redeemer_index)
      ),
      exUnits
    );
  }
};
var setRedeemerstoZero = (tx) => {
  const redeemers = tx.witness_set().redeemers();
  if (!redeemers) return tx;
  const arrLegacyRedeemer = redeemers.as_arr_legacy_redeemer();
  if (arrLegacyRedeemer) {
    const redeemerList = CML.LegacyRedeemerList.new();
    for (let i = 0; i < arrLegacyRedeemer.len(); i++) {
      const redeemer = arrLegacyRedeemer.get(i);
      const dummyRedeemer = CML.LegacyRedeemer.new(
        redeemer.tag(),
        redeemer.index(),
        redeemer.data(),
        CML.ExUnits.new(0n, 0n)
      );
      redeemerList.add(dummyRedeemer);
    }
    const dummyWitnessSet = tx.witness_set();
    dummyWitnessSet.set_redeemers(
      CML.Redeemers.new_arr_legacy_redeemer(redeemerList)
    );
    return CML.Transaction.new(
      tx.body(),
      dummyWitnessSet,
      true,
      tx.auxiliary_data()
    );
  }
  const mapRedeemerKeyToRedeemerVal = redeemers.as_map_redeemer_key_to_redeemer_val();
  if (mapRedeemerKeyToRedeemerVal) {
    const dummyWitnessSet = tx.witness_set();
    dummyWitnessSet.set_redeemers(
      CML.Redeemers.new_map_redeemer_key_to_redeemer_val(
        mapRedeemerKeyToRedeemerVal
      )
    );
    return CML.Transaction.new(
      tx.body(),
      dummyWitnessSet,
      true,
      tx.auxiliary_data()
    );
  }
  return tx;
};
var applyCollateral = (setCollateral, collateralInputs, changeAddress) => Effect17.gen(function* () {
  const { config } = yield* TxConfig;
  for (const utxo of collateralInputs) {
    const collateralInput = CML.SingleInputBuilder.from_transaction_unspent_output(
      utxoToCore3(utxo)
    ).payment_key();
    config.txBuilder.add_collateral(collateralInput);
  }
  const returnassets = pipe9(
    sumAssetsFromInputs(collateralInputs),
    Record2.union({ lovelace: -setCollateral }, _BigInt.sum)
  );
  const collateralOutputBuilder = CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress)
  );
  config.txBuilder.set_collateral_return(
    collateralOutputBuilder.next().with_value(assetsToValue2(returnassets)).build().output()
  );
});
var findCollateral = (coinsPerUtxoByte, setCollateral, inputs) => Effect17.gen(function* () {
  const collateralLovelace = { lovelace: setCollateral };
  const error = completeTxError(
    `Your wallet does not have enough funds to cover the required ${setCollateral} Lovelace collateral. Or it contains UTxOs with reference scripts; which
      are excluded from collateral selection.`
  );
  const { selected } = yield* recursive(
    sortUTxOs(inputs),
    collateralLovelace,
    coinsPerUtxoByte,
    void 0,
    false,
    error
  );
  if (selected.length > 3)
    yield* completeTxError(
      `Selected ${selected.length} inputs as collateral, but max collateral inputs is 3 to cover the ${setCollateral} Lovelace collateral ${stringify(selected)}`
    );
  return selected;
});
var doCoinSelection = (config, availableInputs, script_calculation, includeLeftoverLovelaceAsFee) => Effect17.gen(function* () {
  const estimatedFee = {
    lovelace: yield* estimateFee(config, script_calculation)
  };
  const negatedMintedAssets = negateAssets(config.mintedAssets);
  const negatedCollectedAssets = negateAssets(
    sumAssetsFromInputs(config.collectedInputs)
  );
  const assetsDelta = pipe9(
    config.totalOutputAssets,
    Record2.union(estimatedFee, _BigInt.sum),
    Record2.union(negatedCollectedAssets, _BigInt.sum),
    Record2.union(negatedMintedAssets, _BigInt.sum)
  );
  let requiredAssets = pipe9(
    assetsDelta,
    Record2.filter((amount) => amount > 0n)
  );
  const notRequiredAssets = pipe9(
    assetsDelta,
    Record2.filter((amount) => amount < 0n),
    negateAssets
  );
  return yield* recursive(
    sortUTxOs(availableInputs),
    requiredAssets,
    config.lucidConfig.protocolParameters.coinsPerUtxoByte,
    notRequiredAssets,
    includeLeftoverLovelaceAsFee
  );
});
var estimateFee = (config, script_calculation) => Effect17.gen(function* () {
  const minFee = config.txBuilder.min_fee(script_calculation);
  const refScriptFee = yield* calculateMinRefScriptFee(config);
  let estimatedFee = minFee + refScriptFee;
  const customMinFee = config.minFee;
  if (customMinFee !== void 0 && customMinFee > minFee || refScriptFee > 0n) {
    estimatedFee = customMinFee ? customMinFee > estimatedFee ? customMinFee : estimatedFee : estimatedFee;
    config.txBuilder.set_fee(estimatedFee);
  }
  return estimatedFee;
});
var evalTransactionProvider = (config, txRedeemerBuilder, walletInputs) => Effect17.gen(function* () {
  const txEvaluation = setRedeemerstoZero(txRedeemerBuilder.draft_tx());
  const txUtxos = [...config.collectedInputs, ...config.readInputs].map(
    ({ datumHash, datum, ...rest }) => ({
      ...rest,
      datumHash,
      datum: datumHash ? void 0 : datum
    })
  );
  const uplc_eval = yield* Effect17.tryPromise({
    try: () => config.lucidConfig.provider.evaluateTx(
      txEvaluation.to_cbor_hex(),
      txUtxos
    ),
    catch: (error) => completeTxError(error)
  });
  return uplc_eval;
});
var evalTransaction = (config, txRedeemerBuilder, walletInputs) => Effect17.gen(function* () {
  const txEvaluation = setRedeemerstoZero(txRedeemerBuilder.draft_tx());
  const txUtxos = [
    ...walletInputs,
    ...config.collectedInputs,
    ...config.readInputs
  ].map(({ datumHash, datum, ...rest }) => ({
    ...rest,
    datumHash,
    datum: datumHash ? void 0 : datum
  }));
  const ins = txUtxos.map((utxo) => utxoToTransactionInput(utxo));
  const outs = txUtxos.map((utxo) => utxoToTransactionOutput(utxo));
  const slotConfig = SLOT_CONFIG_NETWORK[config.lucidConfig.network];
  const uplc_eval = yield* Effect17.try({
    try: () => UPLC.eval_phase_two_raw(
      txEvaluation.to_cbor_bytes(),
      ins.map((value) => value.to_cbor_bytes()),
      outs.map((value) => value.to_cbor_bytes()),
      config.lucidConfig.costModels.to_cbor_bytes(),
      config.lucidConfig.protocolParameters.maxTxExSteps,
      config.lucidConfig.protocolParameters.maxTxExMem,
      BigInt(slotConfig.zeroTime),
      BigInt(slotConfig.zeroSlot),
      slotConfig.slotLength
    ),
    catch: (error) => completeTxError(
      `${isError(error) ? error : JSON.stringify(error).replace(/\\n\s*/g, " ").trim()}`
    )
  });
  return uplc_eval;
});
var calculateMinLovelace = (coinsPerUtxoByte, multiAssets, changeAddress) => {
  const dummyAddress = "addr_test1qrngfyc452vy4twdrepdjc50d4kvqutgt0hs9w6j2qhcdjfx0gpv7rsrjtxv97rplyz3ymyaqdwqa635zrcdena94ljs0xy950";
  return CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(changeAddress ? changeAddress : dummyAddress)
  ).next().with_asset_and_min_required_coin(
    multiAssets ? assetsToValue2(multiAssets).multi_asset() : CML.MultiAsset.new(),
    coinsPerUtxoByte
  ).build().output().amount().coin();
};
var calculateMinRefScriptFee = (config) => Effect17.gen(function* () {
  let fee = 0n;
  let totalScriptSize = 0;
  for (const utxo of config.readInputs) {
    if (utxo.scriptRef) {
      totalScriptSize = totalScriptSize + utxo.scriptRef.script.length / 2;
    }
  }
  for (const utxo of config.collectedInputs) {
    if (utxo.scriptRef) {
      totalScriptSize = totalScriptSize + utxo.scriptRef.script.length / 2;
    }
  }
  if (totalScriptSize === 0) return fee;
  const fees = [15, 18, 21.6, 25.92, 31.1, 37.32, 44.79, 53.75];
  let counter = 0;
  while (totalScriptSize > 0) {
    if (counter > fees.length - 1) {
      yield* completeTxError(
        "Total reference script size in a transaction cannot exceed 200,000 bytes."
      );
    }
    if (totalScriptSize > 25e3)
      fee = fee + BigInt(Math.ceil(25e3 * fees[counter]));
    else fee = fee + BigInt(Math.ceil(totalScriptSize * fees[counter]));
    totalScriptSize = totalScriptSize - 25e3;
    counter++;
  }
  return fee;
});
var deriveInputsFromTransaction = (tx) => {
  const outputs = tx.body().outputs();
  const txHash = CML.hash_transaction(tx.body()).to_hex();
  const utxos = [];
  for (let index = 0; index < outputs.len(); index++) {
    const output = outputs.get(index);
    const utxo = {
      txHash,
      outputIndex: index,
      ...coreToTxOutput2(output)
    };
    utxos.push(utxo);
  }
  return utxos;
};
var negateAssets = (assets) => Record2.map(assets, (amount) => -amount);
var sumAssetsFromInputs = (inputs) => _Array.isEmptyArray(inputs) ? {} : inputs.map((utxo) => utxo.assets).reduce((acc, cur) => Record2.union(acc, cur, _BigInt.sum));
var calculateExtraLovelace = (leftoverAssets, coinsPerUtxoByte) => {
  return pipe9(leftoverAssets, (assets) => {
    const minLovelace = calculateMinLovelace(coinsPerUtxoByte, assets);
    const currentLovelace = assets["lovelace"] || 0n;
    return currentLovelace >= minLovelace ? Option.none() : Option.some({ lovelace: minLovelace - currentLovelace });
  });
};
var recursive = (inputs, requiredAssets, coinsPerUtxoByte, externalAssets = {}, includeLeftoverLovelaceAsFee, error) => Effect17.gen(function* () {
  let selected = [];
  error ??= completeTxError(
    `Your wallet does not have enough funds to cover the required assets: ${stringify(requiredAssets)}
      Or it contains UTxOs with reference scripts; which are excluded from coin selection.`
  );
  if (!Record2.isEmptyRecord(requiredAssets)) {
    selected = selectUTxOs(inputs, requiredAssets, true);
    if (_Array.isEmptyArray(selected)) yield* error;
  }
  const selectedAssets = sumAssetsFromInputs(selected);
  let availableAssets = pipe9(
    selectedAssets,
    Record2.union(requiredAssets, (self, that) => self - that),
    Record2.union(externalAssets, _BigInt.sum)
  );
  let extraLovelace = pipe9(
    calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
    Option.getOrUndefined
  );
  let remainingInputs = inputs;
  while (extraLovelace) {
    remainingInputs = _Array.differenceWith(isEqualUTxO)(
      remainingInputs,
      selected
    );
    const extraSelected = selectUTxOs(remainingInputs, extraLovelace, true);
    if (_Array.isEmptyArray(extraSelected)) {
      if (includeLeftoverLovelaceAsFee)
        return { selected: [...selected], burnable: extraLovelace };
      yield* completeTxError(
        `Your wallet does not have enough funds to cover required minimum ADA for change output: ${stringify(extraLovelace)}
          Or it contains UTxOs with reference scripts; which are excluded from coin selection.`
      );
    }
    const extraSelectedAssets = sumAssetsFromInputs(extraSelected);
    selected = [...selected, ...extraSelected];
    availableAssets = Record2.union(
      availableAssets,
      extraSelectedAssets,
      _BigInt.sum
    );
    extraLovelace = pipe9(
      calculateExtraLovelace(availableAssets, coinsPerUtxoByte),
      Option.getOrUndefined
    );
  }
  return { selected, burnable: { lovelace: 0n } };
});

// src/tx-builder/TxBuilder.ts
import { Effect as Effect18, Layer, pipe as pipe10 } from "effect";
import { addAssets as addAssets2 } from "@lucid-evolution/utils";
function makeTxBuilder(lucidConfig) {
  const config = {
    lucidConfig,
    txBuilder: CML.TransactionBuilder.new(lucidConfig.txbuilderconfig),
    walletInputs: [],
    collectedInputs: [],
    readInputs: [],
    consumedInputs: [],
    totalOutputAssets: {},
    payToOutputs: [],
    mintedAssets: {},
    scripts: /* @__PURE__ */ new Map(),
    programs: [],
    partialPrograms: /* @__PURE__ */ new Map(),
    minFee: void 0
  };
  const configLayer = Layer.succeed(TxConfig, { config });
  const txBuilder = {
    readFrom: (utxos) => {
      utxos.map((utxo) => {
        if (utxo.scriptRef) {
          const scriptKeyValue = attachScript(utxo.scriptRef);
          config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        }
      });
      const program = readFrom(utxos);
      config.programs.push(program);
      return txBuilder;
    },
    collectFrom: (utxos, redeemer) => {
      const program = typeof redeemer === "object" ? collectFromUTxOPartial(utxos, redeemer) : collectFromUTxO(utxos)(redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    pay: {
      ToAddress: (address, assets) => {
        const program = payToAddress(address, assets);
        config.programs.push(program);
        return txBuilder;
      },
      ToAddressWithData: (address, outputDatum, assets, scriptRef) => {
        const program = ToAddressWithData(
          address,
          outputDatum,
          assets,
          scriptRef
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToContract: (address, outputDatum, assets, scriptRef) => {
        const program = ToContract(address, outputDatum, assets, scriptRef);
        config.programs.push(program);
        return txBuilder;
      }
    },
    addSigner: (address) => {
      const program = addSigner(address);
      config.programs.push(program);
      return txBuilder;
    },
    addSignerKey: (keyHash) => {
      const program = addSignerKey(keyHash);
      config.programs.push(program);
      return txBuilder;
    },
    registerStake: (rewardAddress) => {
      const program = registerStake(rewardAddress);
      config.programs.push(program);
      return txBuilder;
    },
    register: {
      Stake: (rewardAddress) => {
        const program = registerStake(rewardAddress);
        config.programs.push(program);
        return txBuilder;
      },
      DRep: (rewardAddress, anchor, redeemer) => {
        const program = registerDRep(
          rewardAddress,
          anchor,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    deRegisterStake: (rewardAddress, redeemer) => {
      const program = deRegisterStake(rewardAddress, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    deregister: {
      Stake: (rewardAddress, redeemer) => {
        const program = deRegisterStake(rewardAddress, redeemer);
        config.programs.push(program);
        return txBuilder;
      },
      DRep: (rewardAddress, redeemer) => {
        const program = deregisterDRep(rewardAddress, redeemer);
        config.programs.push(program);
        return txBuilder;
      }
    },
    withdraw: (rewardAddress, amount, redeemer) => {
      const partialProgram = withdraw(rewardAddress, amount);
      handleRedeemerBuilder(config, partialProgram, redeemer);
      return txBuilder;
    },
    mintAssets: (assets, redeemer) => {
      config.mintedAssets = addAssets2(config.mintedAssets, assets);
      const partialProgram = mintAssets(assets);
      handleRedeemerBuilder(config, partialProgram, redeemer);
      return txBuilder;
    },
    validFrom: (unixTime) => {
      const program = validFrom(unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    validTo: (unixTime) => {
      const program = validTo(unixTime);
      config.programs.push(program);
      return txBuilder;
    },
    delegateTo: (rewardAddress, poolId, redeemer) => {
      const program = delegateTo(rewardAddress, poolId, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    delegate: {
      ToPool: (rewardAddress, poolId, redeemer) => {
        const program = delegateTo(rewardAddress, poolId, redeemer);
        config.programs.push(program);
        return txBuilder;
      },
      VoteToDRep: (rewardAddress, drep, redeemer) => {
        const program = delegateVoteToDRep(
          rewardAddress,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      },
      VoteToPoolAndDRep: (rewardAddress, poolId, drep, redeemer) => {
        const program = delegateVoteToPoolAndDRep(
          rewardAddress,
          poolId,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    registerAndDelegate: {
      ToPool: (rewardAddress, poolId, redeemer) => {
        const program = registerAndDelegateToPool(
          rewardAddress,
          poolId,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToDRep: (rewardAddress, drep, redeemer) => {
        const program = registerAndDelegateToDRep(
          rewardAddress,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      },
      ToPoolAndDRep: (rewardAddress, poolId, drep, redeemer) => {
        const program = registerAndDelegateToPoolAndDRep(
          rewardAddress,
          poolId,
          drep,
          redeemer
        );
        config.programs.push(program);
        return txBuilder;
      }
    },
    updateDRep: (rewardAddress, anchor, redeemer) => {
      const program = updateDRep(rewardAddress, anchor, redeemer);
      config.programs.push(program);
      return txBuilder;
    },
    authCommitteeHot: (coldAddress, hotAddress, redeemer) => {
      const program = authCommitteeHot(
        coldAddress,
        hotAddress,
        redeemer
      );
      config.programs.push(program);
      return txBuilder;
    },
    resignCommitteeHot: (coldAddress, anchor, redeemer) => {
      const program = resignCommitteeHot(
        coldAddress,
        anchor,
        redeemer
      );
      config.programs.push(program);
      return txBuilder;
    },
    attachMetadata: (label, metadata) => {
      const program = attachMetadata(config, label, metadata);
      config.programs.push(program);
      return txBuilder;
    },
    attach: {
      Script: (script) => {
        const scriptKeyValue = attachScript(script);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      SpendingValidator: (spendingValidator) => {
        const scriptKeyValue = attachSpendingValidator(spendingValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      MintingPolicy: (mintingPolicy) => {
        const scriptKeyValue = attachMintingPolicy(mintingPolicy);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      CertificateValidator: (certValidator) => {
        const scriptKeyValue = attachCertificateValidator(certValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      WithdrawalValidator: (withdrawalValidator) => {
        const scriptKeyValue = attachWithdrawalValidator(withdrawalValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      VoteValidator: (voteValidator) => {
        const scriptKeyValue = attachVoteValidator(voteValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      },
      ProposeValidator: (proposeValidator) => {
        const scriptKeyValue = attachProposeValidator(proposeValidator);
        config.scripts.set(scriptKeyValue.key, scriptKeyValue.value);
        return txBuilder;
      }
    },
    compose: (tx) => {
      if (tx) {
        const rawConfig = tx.rawConfig();
        config.programs = [...config.programs, ...tx.getPrograms()];
        config.scripts = new Map([...config.scripts, ...rawConfig.scripts]);
        config.mintedAssets = Object.entries({
          ...config.mintedAssets,
          ...rawConfig.mintedAssets
        }).reduce((acc, [key, value]) => {
          acc[key] = (config.mintedAssets[key] || 0n) + BigInt(value);
          return acc;
        }, {});
      }
      return txBuilder;
    },
    setMinFee: (fee) => {
      config.minFee = fee;
      return txBuilder;
    },
    complete: (options) => makeReturn(
      pipe10(
        complete(options),
        Effect18.provide(configLayer),
        Effect18.map((result) => result[2])
      )
    ).unsafeRun(),
    completeProgram: (options) => pipe10(
      complete(options),
      Effect18.provide(configLayer),
      Effect18.map((result) => result[2])
    ),
    completeSafe: (options) => makeReturn(
      pipe10(
        complete(options),
        Effect18.provide(configLayer),
        Effect18.map((result) => result[2])
      )
    ).safeRun(),
    chainProgram: (options) => pipe10(complete(options), Effect18.provide(configLayer)),
    chain: (options) => makeReturn(
      pipe10(complete(options), Effect18.provide(configLayer))
    ).unsafeRun(),
    chainSafe: (options) => makeReturn(
      pipe10(complete(options), Effect18.provide(configLayer))
    ).safeRun(),
    rawConfig: () => config,
    config: () => pipe10(
      Effect18.gen(function* () {
        yield* Effect18.all(config.programs);
        return config;
      }),
      Effect18.provide(configLayer),
      Effect18.runPromise
    ),
    lucidConfig: () => config.lucidConfig,
    getPrograms: () => config.programs
  };
  return txBuilder;
}

// src/tx-builder/TxConfig.ts
var makeTxConfig = (protocolParameters, costModels) => {
  const exUnitsPrices = CML.ExUnitPrices.new(
    CML.Rational.new(
      BigInt(protocolParameters.priceMem * 1e8),
      100000000n
    ),
    CML.Rational.new(
      BigInt(protocolParameters.priceStep * 1e8),
      100000000n
    )
  );
  const txBuilderConfig = CML.TransactionBuilderConfigBuilder.new().fee_algo(
    CML.LinearFee.new(
      BigInt(protocolParameters.minFeeA),
      BigInt(protocolParameters.minFeeB),
      BigInt(protocolParameters.minFeeRefScriptCostPerByte)
    )
  ).coins_per_utxo_byte(protocolParameters.coinsPerUtxoByte).pool_deposit(protocolParameters.poolDeposit).key_deposit(protocolParameters.keyDeposit).max_value_size(protocolParameters.maxValSize).max_tx_size(protocolParameters.maxTxSize).ex_unit_prices(exUnitsPrices).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).cost_models(costModels).collateral_percentage(protocolParameters.collateralPercentage).max_collateral_inputs(protocolParameters.maxCollateralInputs).build();
  return txBuilderConfig;
};

// src/lucid-evolution/LucidEvolution.ts
import { SLOT_CONFIG_NETWORK as SLOT_CONFIG_NETWORK2 } from "@lucid-evolution/plutus";
import {
  makeWalletFromAddress,
  makeWalletFromAPI,
  makeWalletFromPrivateKey,
  makeWalletFromSeed
} from "@lucid-evolution/wallet";
import { Effect as Effect19, pipe as pipe11 } from "effect";
var Lucid = async (provider, network, options = {}) => {
  const protocolParameters = options.presetProtocolParameters || await provider?.getProtocolParameters();
  const costModels = protocolParameters ? createCostModels(protocolParameters.costModels) : void 0;
  const config = {
    provider,
    network,
    wallet: void 0,
    costModels,
    txbuilderconfig: protocolParameters && costModels ? makeTxConfig(protocolParameters, costModels) : void 0,
    protocolParameters
  };
  if (config.provider && "slot" in config.provider) {
    const emulator = config.provider;
    Effect19.gen(function* () {
      const custom = yield* pipe11(
        validateNotNullableNetwork(network)
        // Effect.filterOrFail(
        //   (network) => network === "Custom",
        //   () =>
        //     new UnauthorizedNetwork({
        //       message: `Expected Custom, received ${String(network)}`,
        //     }),
        // ),
      );
      SLOT_CONFIG_NETWORK2[custom] = {
        zeroTime: emulator.now(),
        zeroSlot: 0,
        slotLength: 1e3
      };
    }).pipe(Effect19.runSync);
  }
  return {
    config: () => config,
    wallet: () => config.wallet,
    overrideUTxOs: (utxos) => config.wallet?.overrideUTxOs(utxos),
    switchProvider: async (provider2) => {
      const protocolParam = await provider2.getProtocolParameters();
      const costModels2 = createCostModels(protocolParam.costModels);
      config.provider = provider2;
      config.costModels = costModels2;
      config.txbuilderconfig = makeTxConfig(protocolParam, costModels2);
      config.protocolParameters = protocolParam;
    },
    newTx: () => Effect19.gen(function* () {
      const provider2 = yield* Effect19.fromNullable(config.provider);
      const network2 = yield* Effect19.fromNullable(config.network);
      const costModels2 = yield* validateNotNullable(
        config.costModels,
        "CostModels are not set in Lucid instance"
      );
      const txbuilderconfig = yield* validateNotNullable(
        config.txbuilderconfig,
        "txbuilderconfig is not set in Lucid instance"
      );
      const protocolParameters2 = yield* validateNotNullable(
        config.protocolParameters,
        "protocolParameters are not set in Lucid instance"
      );
      return makeTxBuilder({
        provider: provider2,
        network: network2,
        wallet: config.wallet,
        costModels: costModels2,
        txbuilderconfig,
        protocolParameters: protocolParameters2
      });
    }).pipe(Effect19.runSync),
    fromTx: (tx) => makeTxSignBuilder(
      config.wallet,
      CML.Transaction.from_cbor_hex(tx)
    ),
    selectWallet: {
      fromSeed: (seed, options2) => Effect19.gen(function* () {
        config.wallet = makeWalletFromSeed(
          yield* validateNotNullableProvider(config.provider),
          yield* validateNotNullableNetwork(network),
          seed,
          options2
        );
      }).pipe(Effect19.runSync),
      fromPrivateKey: (privateKey) => Effect19.gen(function* () {
        config.wallet = makeWalletFromPrivateKey(
          yield* validateNotNullableProvider(config.provider),
          yield* validateNotNullableNetwork(network),
          privateKey
        );
      }).pipe(Effect19.runSync),
      fromAPI: (walletAPI) => Effect19.gen(function* () {
        config.wallet = makeWalletFromAPI(
          yield* validateNotNullableProvider(config.provider),
          walletAPI
        );
      }).pipe(Effect19.runSync),
      fromAddress: (address, utxos) => Effect19.gen(function* () {
        config.wallet = makeWalletFromAddress(
          yield* validateNotNullableProvider(config.provider),
          yield* validateNotNullableNetwork(network),
          address,
          utxos
        );
      }).pipe(Effect19.runSync)
    },
    currentSlot: () => pipe11(
      validateNotNullableNetwork(config.network),
      Effect19.map((network2) => unixTimeToSlot2(network2, Date.now())),
      Effect19.runSync
    ),
    unixTimeToSlot: (unixTime) => pipe11(
      validateNotNullableNetwork(config.network),
      Effect19.map((network2) => unixTimeToSlot2(network2, unixTime)),
      Effect19.runSync
    ),
    utxosAt: (addressOrCredential) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(() => provider2.getUtxos(addressOrCredential))
      ),
      Effect19.runPromise
    ),
    utxosAtWithUnit: (addressOrCredential, unit) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(
          () => provider2.getUtxosWithUnit(addressOrCredential, unit)
        )
      ),
      Effect19.runPromise
    ),
    utxoByUnit: (unit) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(() => provider2.getUtxoByUnit(unit))
      ),
      Effect19.runPromise
    ),
    utxosByOutRef: (outRefs) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(() => provider2.getUtxosByOutRef(outRefs))
      ),
      Effect19.runPromise
    ),
    delegationAt: (rewardAddress) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(() => provider2.getDelegation(rewardAddress))
      ),
      Effect19.runPromise
    ),
    awaitTx: (txHash, checkInterval) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(() => provider2.awaitTx(txHash, checkInterval))
      ),
      Effect19.runPromise
    ),
    datumOf: (utxo, type) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(() => datumOf(provider2, utxo, type))
      ),
      Effect19.runPromise
    ),
    metadataOf: (unit) => pipe11(
      validateNotNullableProvider(config.provider),
      Effect19.flatMap(
        (provider2) => Effect19.promise(() => metadataOf(provider2, unit))
      ),
      Effect19.runPromise
    )
  };
};
var validateNotNullable = (value, message) => pipe11(
  Effect19.fromNullable(value),
  Effect19.orElseFail(() => new NullableError({ message }))
);
var validateNotNullableNetwork = (network) => validateNotNullable(network, "Network is not set in Lucid instance");
var validateNotNullableProvider = (provider) => validateNotNullable(provider, "Provider is not set in Lucid instance");

// src/index.ts
export * from "@lucid-evolution/core-types";
export * from "@lucid-evolution/core-utils";
export * from "@lucid-evolution/plutus";
export * from "@lucid-evolution/provider";
export * from "@lucid-evolution/sign_data";
export * from "@lucid-evolution/utils";
export * from "@lucid-evolution/wallet";
export {
  CML,
  ERROR_MESSAGE,
  Lucid,
  NullableError,
  RunTimeError,
  TxBuilderError,
  TxSignerError,
  TxSubmitError,
  UnauthorizedNetwork,
  makeReturn,
  makeSubmit,
  makeTxBuilder,
  makeTxSignBuilder
};
//# sourceMappingURL=index.js.map