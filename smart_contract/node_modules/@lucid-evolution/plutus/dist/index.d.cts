import * as TypeBox from '@sinclair/typebox';
export * from '@sinclair/typebox';
import { Datum, Redeemer, Exact, Json, Network, SlotConfig, Slot, UnixTime } from '@lucid-evolution/core-types';

declare class Constr<T> {
    index: number;
    fields: T[];
    constructor(index: number, fields: T[]);
}
declare namespace Data {
    type Static<T extends TypeBox.TSchema, P extends unknown[] = []> = TypeBox.Static<T, P>;
}
type Data = bigint | string | Array<Data> | Map<Data, Data> | Constr<Data>;
declare const Data: {
    Integer: (options?: {
        minimum?: number;
        maximum?: number;
        exclusiveMinimum?: number;
        exclusiveMaximum?: number;
    }) => TypeBox.TUnsafe<bigint>;
    Bytes: (options?: {
        minLength?: number;
        maxLength?: number;
        enum?: string[];
    }) => TypeBox.TUnsafe<string>;
    Boolean: () => TypeBox.TUnsafe<boolean>;
    Any: () => TypeBox.TUnsafe<Data>;
    Array: <T extends TypeBox.TSchema>(items: T, options?: {
        minItems?: number;
        maxItems?: number;
        uniqueItems?: boolean;
    }) => TypeBox.TArray<T>;
    Map: <T extends TypeBox.TSchema, U extends TypeBox.TSchema>(keys: T, values: U, options?: {
        minItems?: number;
        maxItems?: number;
    }) => TypeBox.TUnsafe<Map<Data.Static<T, []>, Data.Static<U, []>>>;
    /**
     * Object applies by default a PlutusData Constr with index 0.\
     * Set 'hasConstr' to false to serialize Object as PlutusData List.
     */
    Object: <T extends TypeBox.TProperties>(properties: T, options?: {
        hasConstr?: boolean;
    }) => TypeBox.TObject<T>;
    Enum: <T extends TypeBox.TSchema>(items: T[]) => TypeBox.TUnion<T[]>;
    /**
     * Tuple is by default a PlutusData List.\
     * Set 'hasConstr' to true to apply a PlutusData Constr with index 0.
     */
    Tuple: <T extends TypeBox.TSchema[]>(items: [...T], options?: {
        hasConstr?: boolean;
    }) => TypeBox.TTuple<T>;
    Literal: <T extends TypeBox.TLiteralValue>(title: T) => TypeBox.TLiteral<T>;
    Nullable: <T extends TypeBox.TSchema>(item: T) => TypeBox.TUnsafe<Data.Static<T, []> | null>;
    /**
     * Convert PlutusData to Cbor encoded data.\
     * Or apply a shape and convert the provided data struct to Cbor encoded data.
     */
    to: typeof to;
    /** Convert Cbor encoded data to PlutusData */
    from: typeof from;
    /**
     * Note Constr cannot be used here.\
     * Strings prefixed with '0x' are not UTF-8 encoded.
     */
    fromJson: typeof fromJson;
    /**
     * Note Constr cannot be used here, also only bytes/integers as Json keys.\
     */
    toJson: typeof toJson;
    void: () => Datum | Redeemer;
    castFrom: typeof castFrom;
    castTo: typeof castTo;
};
/**
 * Convert PlutusData or Schema to CBOR-encoded data
 *
 * By default, the `canonical` option is set to `false`.
 *
 * @example Non Canonical format:
 * ```ts
 * Data.to<Data>(new Constr(0, ["deadbeef"])) -> 'd8799f44deadbeefff';
 * ```
 *
 * @example Canonical format:
 * ```ts
 * Data.to<Data>(new Constr(0, ["deadbeef"]), undefined, { canonical: true }) -> 'd8798144deadbeef';
 * ```
 *
 * Returns the encoded CBOR data as either `Datum` or `Redeemer`.
 */
declare function to<T = Data>(data: Exact<T>, type?: T, options?: {
    canonical?: boolean;
}): Datum | Redeemer;
/**
 *  Convert Cbor encoded data to Data.\
 *  Or apply a shape and cast the cbor encoded data to a certain type.
 */
declare function from<T = Data>(raw: Datum | Redeemer, type?: T): T;
/**
 * Note Constr cannot be used here.\
 * Strings prefixed with '0x' are not UTF-8 encoded.
 */
declare function fromJson(json: Json): Data;
/**
 * Note Constr cannot be used here, also only bytes/integers as Json keys.\
 */
declare function toJson(plutusData: Data): Json;
declare function castFrom<T = Data>(data: Data, type: T): T;
declare function castTo<T>(struct: Exact<T>, type: T): Data;

declare const SLOT_CONFIG_NETWORK: Record<Network, SlotConfig>;
declare function slotToBeginUnixTime(slot: Slot, slotConfig: SlotConfig): UnixTime;
declare function unixTimeToEnclosingSlot(unixTime: UnixTime, slotConfig: SlotConfig): Slot;

export { Constr, Data, SLOT_CONFIG_NETWORK, slotToBeginUnixTime, unixTimeToEnclosingSlot };
