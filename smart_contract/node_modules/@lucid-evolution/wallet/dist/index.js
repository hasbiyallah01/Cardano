// src/wallet.ts
import { getAddressDetails } from "@lucid-evolution/utils";
import { fromHex } from "@lucid-evolution/core-utils";

// src/core.ts
import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";

// src/wallet.ts
import { mnemonicToEntropy } from "bip39";
function walletFromSeed(seed, options = {}) {
  const {
    addressType = "Base",
    accountIndex = 0,
    network = "Mainnet"
  } = options;
  function harden(num) {
    if (typeof num !== "number") throw new Error("Type number required here!");
    return 2147483648 + num;
  }
  const entropy = mnemonicToEntropy(seed);
  const rootKey = CML.Bip32PrivateKey.from_bip39_entropy(
    fromHex(entropy),
    options?.password ? new TextEncoder().encode(options.password) : new Uint8Array()
  );
  const accountKey = rootKey.derive(harden(1852)).derive(harden(1815)).derive(harden(accountIndex));
  rootKey.free();
  const paymentKey = accountKey.derive(0).derive(0).to_raw_key();
  const stakeKey = accountKey.derive(2).derive(0).to_raw_key();
  const paymentKeyHash = paymentKey.to_public().hash();
  const stakeKeyHash = stakeKey.to_public().hash();
  const networkId = network === "Mainnet" ? 1 : 0;
  const address = addressType === "Base" ? CML.BaseAddress.new(
    networkId,
    CML.Credential.new_pub_key(paymentKeyHash),
    CML.Credential.new_pub_key(stakeKeyHash)
  ).to_address().to_bech32(void 0) : CML.EnterpriseAddress.new(
    networkId,
    CML.Credential.new_pub_key(paymentKeyHash)
  ).to_address().to_bech32(void 0);
  const rewardAddress = addressType === "Base" ? CML.RewardAddress.new(
    networkId,
    CML.Credential.new_pub_key(stakeKeyHash)
  ).to_address().to_bech32(void 0) : null;
  return {
    address,
    rewardAddress,
    paymentKey: paymentKey.to_bech32(),
    stakeKey: addressType === "Base" ? stakeKey.to_bech32() : null
  };
}
function discoverOwnUsedTxKeyHashes(tx, ownKeyHashes, ownUtxos) {
  const usedKeyHashes = [];
  const inputs = tx.body().inputs();
  for (let i = 0; i < inputs.len(); i++) {
    const input = inputs.get(i);
    const txHash = input.transaction_id().to_hex();
    const outputIndex = Number(input.index());
    const utxo = ownUtxos.find(
      (utxo2) => utxo2.txHash === txHash && utxo2.outputIndex === outputIndex
    );
    if (utxo) {
      const { paymentCredential } = getAddressDetails(utxo.address);
      usedKeyHashes.push(paymentCredential?.hash);
    }
  }
  const txBody = tx.body();
  function keyHashFromCert(txBody2) {
    const certs = txBody2.certs();
    if (!certs) return;
    for (let i = 0; i < certs.len(); i++) {
      const cert = certs.get(i);
      switch (cert.kind()) {
        case 0:
          break;
        case 1: {
          const credential = cert.as_stake_deregistration()?.stake_credential();
          switch (credential?.kind()) {
            case 0:
              usedKeyHashes.push(credential.as_pub_key()?.to_hex());
              break;
            case 1:
              usedKeyHashes.push(credential.as_script()?.to_hex());
              break;
          }
          break;
        }
        case 2: {
          const credential = cert.as_stake_delegation()?.stake_credential();
          if (credential?.kind() === 0) {
            const keyHash = credential.as_pub_key()?.to_hex();
            usedKeyHashes.push(keyHash);
          }
          break;
        }
        case 3: {
          const poolParams = cert.as_pool_registration()?.pool_params();
          const owners = poolParams?.pool_owners();
          if (!owners) break;
          for (let i2 = 0; i2 < owners.len(); i2++) {
            const keyHash = owners.get(i2).to_hex();
            usedKeyHashes.push(keyHash);
          }
          const operator = poolParams.operator().to_hex();
          usedKeyHashes.push(operator);
          break;
        }
        case 4: {
          const operator = cert.as_pool_retirement()?.pool().to_hex();
          usedKeyHashes.push(operator);
          break;
        }
        case 6: {
          const credential = cert.as_unreg_cert()?.stake_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 7: {
          const credential = cert.as_vote_deleg_cert()?.stake_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 8: {
          const credential = cert.as_stake_vote_deleg_cert()?.stake_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 9: {
          const credential = cert.as_stake_reg_deleg_cert()?.stake_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 10: {
          const credential = cert.as_vote_reg_deleg_cert()?.stake_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 11: {
          const credential = cert.as_stake_vote_reg_deleg_cert()?.stake_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 12: {
          const credential = cert.as_auth_committee_hot_cert()?.committee_cold_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 13: {
          const credential = cert.as_resign_committee_cold_cert()?.committee_cold_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 14: {
          const credential = cert.as_reg_drep_cert()?.drep_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 15: {
          const credential = cert.as_unreg_drep_cert()?.drep_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        case 16: {
          const credential = cert.as_update_drep_cert()?.drep_credential();
          if (credential) {
            usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          }
          break;
        }
        default:
          break;
      }
    }
  }
  if (txBody.certs()) keyHashFromCert(txBody);
  const withdrawals = txBody.withdrawals();
  function keyHashFromWithdrawal(withdrawals2) {
    const rewardAddresses = withdrawals2.keys();
    for (let i = 0; i < rewardAddresses.len(); i++) {
      const credential = rewardAddresses.get(i).payment();
      switch (credential.kind()) {
        case 0:
          usedKeyHashes.push(credential.as_pub_key()?.to_hex());
          break;
        case 1:
          usedKeyHashes.push(credential.as_script()?.to_hex());
          break;
      }
    }
  }
  if (withdrawals) keyHashFromWithdrawal(withdrawals);
  const scripts = tx.witness_set().native_scripts();
  function keyHashFromScript(scripts2) {
    for (let i = 0; i < scripts2.len(); i++) {
      const script = scripts2.get(i);
      if (script.kind() === 0) {
        const keyHash = script.as_script_pubkey()?.ed25519_key_hash().to_hex();
        usedKeyHashes.push(keyHash);
      }
      if (script.kind() === 1) {
        keyHashFromScript(script.as_script_all().native_scripts());
        return;
      }
      if (script.kind() === 2) {
        keyHashFromScript(script.as_script_any().native_scripts());
        return;
      }
      if (script.kind() === 3) {
        keyHashFromScript(script.as_script_n_of_k().native_scripts());
        return;
      }
    }
  }
  if (scripts) keyHashFromScript(scripts);
  const requiredSigners = txBody.required_signers();
  if (requiredSigners) {
    for (let i = 0; i < requiredSigners.len(); i++) {
      usedKeyHashes.push(requiredSigners.get(i).to_hex());
    }
  }
  const collateral = txBody.collateral_inputs();
  if (collateral) {
    for (let i = 0; i < collateral.len(); i++) {
      const input = collateral.get(i);
      const txHash = input.transaction_id().to_hex();
      const outputIndex = Number(input.index());
      const utxo = ownUtxos.find(
        (utxo2) => utxo2.txHash === txHash && utxo2.outputIndex === outputIndex
      );
      if (utxo) {
        const { paymentCredential } = getAddressDetails(utxo.address);
        usedKeyHashes.push(paymentCredential?.hash);
      }
    }
  }
  return usedKeyHashes.filter((k) => ownKeyHashes.includes(k));
}

// src/wallet_selection.ts
import { fromHex as fromHex2, toHex } from "@lucid-evolution/core-utils";
import {
  coreToUtxo,
  credentialToRewardAddress,
  getAddressDetails as getAddressDetails2,
  utxoToCore
} from "@lucid-evolution/utils";
import { signData } from "@lucid-evolution/sign_data";
var makeWalletFromSeed = (provider, network, seed, options) => {
  const config = {
    overriddenUTxOs: []
  };
  const { address, rewardAddress, paymentKey, stakeKey } = walletFromSeed(
    seed,
    {
      addressType: options?.addressType || "Base",
      accountIndex: options?.accountIndex || 0,
      password: options?.password,
      network
    }
  );
  const paymentKeyHash = CML.PrivateKey.from_bech32(paymentKey).to_public().hash().to_hex();
  const stakeKeyHash = stakeKey ? CML.PrivateKey.from_bech32(stakeKey).to_public().hash().to_hex() : "";
  const privKeyHashMap = {
    [paymentKeyHash]: paymentKey,
    [stakeKeyHash]: stakeKey
  };
  return {
    overrideUTxOs: (utxos) => config.overriddenUTxOs = utxos,
    address: async () => address,
    rewardAddress: async () => rewardAddress || null,
    getUtxos: async () => config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : provider.getUtxos(address),
    getUtxosCore: async () => {
      const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
      const coreUtxos = [];
      for (const utxo of utxos) {
        coreUtxos.push(utxoToCore(utxo));
      }
      return coreUtxos;
    },
    getDelegation: async () => {
      return rewardAddress ? await provider.getDelegation(rewardAddress) : { poolId: null, rewards: 0n };
    },
    signTx: async (tx) => {
      const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
      const ownKeyHashes = [paymentKeyHash, stakeKeyHash];
      const usedKeyHashes = discoverOwnUsedTxKeyHashes(tx, ownKeyHashes, utxos);
      const txWitnessSetBuilder = CML.TransactionWitnessSetBuilder.new();
      for (const keyHash of usedKeyHashes) {
        const priv = CML.PrivateKey.from_bech32(privKeyHashMap[keyHash]);
        const witness = CML.make_vkey_witness(
          CML.hash_transaction(tx.body()),
          priv
        );
        txWitnessSetBuilder.add_vkey(witness);
      }
      return txWitnessSetBuilder.build();
    },
    signMessage: async (address2, payload) => {
      const {
        paymentCredential,
        stakeCredential,
        address: { hex: hexAddress }
      } = getAddressDetails2(address2);
      const keyHash = paymentCredential?.hash || stakeCredential?.hash;
      const privateKey = privKeyHashMap[keyHash];
      if (!privateKey) {
        throw new Error(`Cannot sign message for address: ${address2}.`);
      }
      return signData(hexAddress, payload, privateKey);
    },
    submitTx: async (tx) => provider.submitTx(tx)
  };
};
var makeWalletFromPrivateKey = (provider, network, privateKey) => {
  const priv = CML.PrivateKey.from_bech32(privateKey);
  const pubKeyHash = priv.to_public().hash();
  const address = CML.EnterpriseAddress.new(
    network === "Mainnet" ? 1 : 0,
    CML.Credential.new_pub_key(pubKeyHash)
  ).to_address().to_bech32(void 0);
  const config = {
    overriddenUTxOs: []
  };
  return {
    overrideUTxOs: (utxos) => config.overriddenUTxOs = utxos,
    address: async () => address,
    rewardAddress: async () => null,
    getUtxos: async () => config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : provider.getUtxos(address),
    getUtxosCore: async () => {
      const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
      const coreUtxos = [];
      for (const utxo of utxos) {
        coreUtxos.push(utxoToCore(utxo));
      }
      return coreUtxos;
    },
    getDelegation: async () => {
      return { poolId: null, rewards: 0n };
    },
    signTx: async (tx) => {
      const witness = CML.make_vkey_witness(
        CML.hash_transaction(tx.body()),
        priv
      );
      const txWitnessSetBuilder = CML.TransactionWitnessSetBuilder.new();
      txWitnessSetBuilder.add_vkey(witness);
      return txWitnessSetBuilder.build();
    },
    signMessage: async (address2, payload) => {
      const {
        paymentCredential,
        address: { hex: hexAddress }
      } = getAddressDetails2(address2);
      const keyHash = paymentCredential?.hash;
      const originalKeyHash = pubKeyHash.to_hex();
      if (!keyHash || keyHash !== originalKeyHash) {
        throw new Error(`Cannot sign message for address: ${address2}.`);
      }
      return signData(hexAddress, payload, privateKey);
    },
    submitTx: async (tx) => {
      return await provider.submitTx(tx);
    }
  };
};
var makeWalletFromAPI = (provider, api) => {
  const config = {
    overriddenUTxOs: []
  };
  const getAddressHex = async () => {
    const [addressHex] = await api.getUsedAddresses();
    if (addressHex) return addressHex;
    const [unusedAddressHex] = await api.getUnusedAddresses();
    return unusedAddressHex;
  };
  const getRewardAddress = async () => {
    const [rewardAddressHex] = await api.getRewardAddresses();
    const rewardAddress = rewardAddressHex ? CML.RewardAddress.from_address(CML.Address.from_hex(rewardAddressHex)).to_address().to_bech32(void 0) : null;
    return rewardAddress;
  };
  return {
    overrideUTxOs: (utxos) => config.overriddenUTxOs = utxos,
    address: async () => CML.Address.from_hex(await getAddressHex()).to_bech32(void 0),
    rewardAddress: async () => getRewardAddress(),
    getUtxos: async () => {
      const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : (await api.getUtxos() || []).map(
        (utxo) => coreToUtxo(
          CML.TransactionUnspentOutput.from_cbor_bytes(fromHex2(utxo))
        )
      );
      return utxos;
    },
    getUtxosCore: async () => {
      const utxos = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs.map(utxoToCore) : (await api.getUtxos() || []).map(
        (utxo) => CML.TransactionUnspentOutput.from_cbor_hex(utxo)
      );
      return utxos;
    },
    getDelegation: async () => {
      const rewardAddr = await getRewardAddress();
      return rewardAddr ? await provider.getDelegation(rewardAddr) : { poolId: null, rewards: 0n };
    },
    signTx: async (tx) => {
      const witnessSet = await api.signTx(toHex(tx.to_cbor_bytes()), true);
      return CML.TransactionWitnessSet.from_cbor_hex(witnessSet);
    },
    signMessage: async (address, payload) => {
      const hexAddress = toHex(CML.Address.from_bech32(address).to_raw_bytes());
      return await api.signData(hexAddress, payload);
    },
    submitTx: async (tx) => api.submitTx(tx)
  };
};
var makeWalletFromAddress = (provider, network, address, utxos) => {
  const { stakeCredential } = getAddressDetails2(address);
  const rewardAddress = stakeCredential ? credentialToRewardAddress(network, stakeCredential) : null;
  const config = {
    overriddenUTxOs: utxos
  };
  return {
    overrideUTxOs: (utxos2) => config.overriddenUTxOs = utxos2,
    address: async () => address,
    rewardAddress: async () => rewardAddress,
    getUtxos: async () => config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : provider.getUtxos(address),
    getUtxosCore: async () => {
      const utxos2 = config.overriddenUTxOs.length > 0 ? config.overriddenUTxOs : await provider.getUtxos(address);
      const coreUtxos = [];
      for (const utxo of utxos2) {
        coreUtxos.push(utxoToCore(utxo));
      }
      return coreUtxos;
    },
    getDelegation: async () => rewardAddress ? provider.getDelegation(rewardAddress) : { poolId: null, rewards: 0n },
    signTx: async (_tx) => {
      throw new Error("Not implemented");
    },
    signMessage: async (_address, _payload) => {
      throw new Error("Not implemented");
    },
    submitTx: async (tx) => provider.submitTx(tx)
  };
};
export {
  discoverOwnUsedTxKeyHashes,
  makeWalletFromAPI,
  makeWalletFromAddress,
  makeWalletFromPrivateKey,
  makeWalletFromSeed,
  walletFromSeed
};
