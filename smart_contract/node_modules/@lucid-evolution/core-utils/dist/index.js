// src/core-utils.ts
function assert_bytes(b, ...lengths) {
  if (!isBytes(b)) throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(
      `Uint8Array expected of length ${lengths}, not of length=${b.length}`
    );
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
  return;
}
var hexes = /* @__PURE__ */ Array.from(
  { length: 256 },
  (_, i) => i.toString(16).padStart(2, "0")
);
function fromHex(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error(
      "padded hex string expected, got unpadded hex of length " + hl
    );
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + char + '" at index ' + hi
      );
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function toHex(bytes) {
  assert_bytes(bytes);
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
function toText(hex) {
  return new TextDecoder().decode(fromHex(hex)).toString();
}
function fromText(text) {
  return toHex(new TextEncoder().encode(text));
}
var sleep = (ms = 1e3) => new Promise((r) => setTimeout(r, ms));
export {
  fromHex,
  fromText,
  isBytes,
  sleep,
  toHex,
  toText
};
