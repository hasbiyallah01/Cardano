import * as CML from '@anastasia-labs/cardano-multiplatform-lib-nodejs';

type CostModel = Record<string, number>;
type CostModels = Record<PlutusVersion, CostModel>;
type ProtocolParameters = {
    minFeeA: number;
    minFeeB: number;
    maxTxSize: number;
    maxValSize: number;
    keyDeposit: bigint;
    poolDeposit: bigint;
    drepDeposit: bigint;
    govActionDeposit: bigint;
    priceMem: number;
    priceStep: number;
    maxTxExMem: bigint;
    maxTxExSteps: bigint;
    coinsPerUtxoByte: bigint;
    collateralPercentage: number;
    maxCollateralInputs: number;
    minFeeRefScriptCostPerByte: number;
    costModels: CostModels;
};
type Slot = number;
interface Provider {
    getProtocolParameters(): Promise<ProtocolParameters>;
    /** Query UTxOs by address or payment credential. */
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    /** Query UTxOs by address or payment credential filtered by a specific unit. */
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    /** Query a UTxO by a unit. It needs to be an NFT (or optionally the entire supply in one UTxO). */
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    /** Query UTxOs by the output reference (tx hash and index). */
    getUtxosByOutRef(outRefs: Array<OutRef>): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}
/**
 * Follows WebSocket API Reference [ScriptPurpose](https://ogmios.dev/api/#schema-ScriptPurpose)
 */
type RedeemerTag = "spend" | "mint" | "publish" | "withdraw" | "vote" | "propose";
type EvalRedeemer = {
    ex_units: {
        mem: number;
        steps: number;
    };
    redeemer_index: number;
    redeemer_tag: RedeemerTag;
};
type Credential = {
    type: "Key" | "Script";
    hash: KeyHash | ScriptHash;
};
/** Concatenation of policy id and asset name in Hex. */
type Unit = string;
type Assets = Record<Unit | "lovelace", bigint>;
type ScriptType = "Native" | PlutusVersion;
type PlutusVersion = "PlutusV1" | "PlutusV2" | "PlutusV3";
/** Hex */
type PolicyId = string;
type Script = {
    type: ScriptType;
    script: string;
};
type Validator = MintingPolicy | SpendingValidator | CertificateValidator | WithdrawalValidator | VoteValidator | ProposeValidator;
type MintingPolicy = Script;
type SpendingValidator = Script;
type CertificateValidator = Script;
type WithdrawalValidator = Script;
type VoteValidator = Script;
type ProposeValidator = Script;
/** Bech32 */
type Address = string;
/** Bech32 */
type RewardAddress = string;
/** Hex */
type PaymentKeyHash = string;
/** Hex */
type StakeKeyHash = string;
/** Hex */
type KeyHash = string | PaymentKeyHash | StakeKeyHash;
/** Hex */
type VrfKeyHash = string;
/** Hex */
type ScriptHash = string;
/** Hex */
type TxHash = string;
/** Bech32 */
type PoolId = string;
/** Hex */
type Datum = string;
/**
 * **hash** adds the datum hash to the output.
 *
 * **asHash** hashes the datum and adds the datum hash to the output and the datum to the witness set.
 *
 * **inline** adds the datum to the output.
 *
 * **scriptRef** will add any script to the output.
 *
 * You can either specify **hash**, **asHash** or **inline**, only one option is allowed.
 */
type OutputData = {
    hash?: DatumHash;
    asHash?: Datum;
    inline?: Datum;
    scriptRef?: Script;
};
/** Hex */
type DatumHash = string;
/** Hex (Redeemer is only PlutusData, same as Datum) */
type Redeemer = string;
/** TODO docs  */
type RedeemerBuilder = {
    kind: "selected";
    makeRedeemer: (inputIndices: bigint[]) => Redeemer;
    inputs: UTxO[];
} | {
    kind: "self";
    makeRedeemer: (inputIndex: bigint) => Redeemer;
    inputs?: UTxO[];
};
type Lovelace = bigint;
type Label = number;
/** Hex */
type TransactionWitnesses = string;
/** Hex */
type Transaction = string;
/** Bech32 */
type PrivateKey = string;
/** Bech32 */
type PublicKey = string;
/** Hex */
type ScriptRef = string;
/** Hex */
type Payload = string;
type UTxO = OutRef & TxOutput;
type OutRef = {
    txHash: TxHash;
    outputIndex: number;
};
type TxOutput = {
    address: Address;
    assets: Assets;
    datumHash?: DatumHash | null;
    datum?: Datum | null;
    scriptRef?: Script | null;
};
type AddressType = "Base" | "Enterprise" | "Pointer" | "Reward" | "Byron";
type Network = "Mainnet" | "Preview" | "Preprod" | "Custom";
type AddressDetails = {
    type: AddressType;
    networkId: number;
    address: {
        bech32: Address;
        hex: string;
    };
    paymentCredential?: Credential;
    stakeCredential?: Credential;
};
type Delegation = {
    poolId: PoolId | null;
    rewards: Lovelace;
};
/**
 * A wallet that can be constructed from external data e.g utxos and an address.
 * It doesn't allow you to sign transactions/messages. This needs to be handled separately.
 */
interface ExternalWallet {
    address: Address;
    utxos?: UTxO[];
    rewardAddress?: RewardAddress;
}
type SignedMessage = {
    signature: string;
    key: string;
};
interface Wallet {
    overrideUTxOs(utxos: UTxO[]): void;
    address(): Promise<Address>;
    rewardAddress(): Promise<RewardAddress | null>;
    getUtxos(): Promise<UTxO[]>;
    getUtxosCore(): Promise<Array<CML.TransactionUnspentOutput>>;
    getDelegation(): Promise<Delegation>;
    signTx(tx: CML.Transaction): Promise<CML.TransactionWitnessSet>;
    signMessage(address: Address | RewardAddress, payload: Payload): Promise<SignedMessage>;
    submitTx(signedTx: Transaction): Promise<TxHash>;
}
/** JSON object */
type Json = any;
/** Time in milliseconds */
type UnixTime = number;
type PoolParams = {
    poolId: PoolId;
    vrfKeyHash: VrfKeyHash;
    pledge: Lovelace;
    cost: Lovelace;
    margin: number;
    rewardAddress: RewardAddress;
    owners: Array<RewardAddress>;
    relays: Array<Relay>;
    metadataUrl?: string;
};
type Relay = {
    type: "SingleHostIp" | "SingleHostDomainName" | "MultiHost";
    ipV4?: string;
    ipV6?: string;
    port?: number;
    domainName?: string;
};
/**
 * Represents a cardano-cli JSON script syntax
 *
 * Native type follows the standard described in the
 * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
 */
type Native = {
    type: "sig";
    keyHash: string;
} | {
    type: "before";
    slot: number;
} | {
    type: "after";
    slot: number;
} | {
    type: "all";
    scripts: ReadonlyArray<Native>;
} | {
    type: "any";
    scripts: ReadonlyArray<Native>;
} | {
    type: "atLeast";
    required: number;
    scripts: ReadonlyArray<Native>;
};
type SlotConfig = {
    zeroTime: UnixTime;
    zeroSlot: Slot;
    slotLength: number;
};
type Exact<T> = T extends infer U ? U : never;
type Metadata = {
    222: {
        name: string;
        image: string;
        mediaType?: string;
        description?: string;
        files?: {
            name?: string;
            mediaType: string;
            src: string;
        }[];
        [key: string]: Json;
    };
    333: {
        name: string;
        description: string;
        ticker?: string;
        url?: string;
        logo?: string;
        decimals?: number;
        [key: string]: Json;
    };
    444: Metadata["222"] & {
        decimals?: number;
    };
};
type DatumJson = {
    int?: number;
    bytes?: string;
    list?: Array<DatumJson>;
    map?: Array<{
        k: unknown;
        v: unknown;
    }>;
    fields?: Array<DatumJson>;
    [constructor: string]: unknown;
};
type Anchor = {
    url: string;
    dataHash: string;
};
type AlwaysAbstain = {
    __typename: "AlwaysAbstain";
};
type AlwaysNoConfidence = {
    __typename: "AlwaysNoConfidence";
};
type DRep = Credential | AlwaysAbstain | AlwaysNoConfidence;

type WalletApi = {
    getNetworkId(): Promise<number>;
    getUtxos(): Promise<string[] | undefined>;
    getBalance(): Promise<string>;
    getUsedAddresses(): Promise<string[]>;
    getUnusedAddresses(): Promise<string[]>;
    getChangeAddress(): Promise<string>;
    getRewardAddresses(): Promise<string[]>;
    signTx(tx: string, partialSign: boolean): Promise<string>;
    signData(address: string, payload: string): Promise<{
        signature: string;
        key: string;
    }>;
    submitTx(tx: string): Promise<string>;
    getCollateral(): Promise<string[]>;
    experimental: {
        getCollateral(): Promise<string[]>;
        on(eventName: string, callback: (...args: unknown[]) => void): void;
        off(eventName: string, callback: (...args: unknown[]) => void): void;
    };
};
type Cardano = {
    [key: string]: {
        name: string;
        icon: string;
        apiVersion: string;
        enable(): Promise<WalletApi>;
        isEnabled(): Promise<boolean>;
    };
};
declare global {
    interface Window {
        cardano: Cardano;
    }
}

export type { Address, AddressDetails, AddressType, AlwaysAbstain, AlwaysNoConfidence, Anchor, Assets, Cardano, CertificateValidator, CostModels, Credential, DRep, Datum, DatumHash, DatumJson, Delegation, EvalRedeemer, Exact, ExternalWallet, Json, KeyHash, Label, Lovelace, Metadata, MintingPolicy, Native, Network, OutRef, OutputData, Payload, PaymentKeyHash, PlutusVersion, PolicyId, PoolId, PoolParams, PrivateKey, ProposeValidator, ProtocolParameters, Provider, PublicKey, Redeemer, RedeemerBuilder, RedeemerTag, Relay, RewardAddress, Script, ScriptHash, ScriptRef, ScriptType, SignedMessage, Slot, SlotConfig, SpendingValidator, StakeKeyHash, Transaction, TransactionWitnesses, TxHash, TxOutput, UTxO, Unit, UnixTime, Validator, VoteValidator, VrfKeyHash, Wallet, WalletApi, WithdrawalValidator };
