// src/native.ts
import * as S from "@effect/schema/Schema";

// src/core.ts
import * as CML from "@anastasia-labs/cardano-multiplatform-lib-nodejs";

// src/native.ts
var toCMLNativeScript = (native) => {
  switch (native.type) {
    case "sig":
      return CML.NativeScript.new_script_pubkey(
        CML.Ed25519KeyHash.from_hex(native.keyHash)
      );
    case "before":
      return CML.NativeScript.new_script_invalid_hereafter(BigInt(native.slot));
    case "after":
      return CML.NativeScript.new_script_invalid_before(BigInt(native.slot));
    case "all": {
      const nativeList = CML.NativeScriptList.new();
      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
      return CML.NativeScript.new_script_all(nativeList);
    }
    case "any": {
      const nativeList = CML.NativeScriptList.new();
      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
      return CML.NativeScript.new_script_any(nativeList);
    }
    case "atLeast": {
      const nativeList = CML.NativeScriptList.new();
      native.scripts.map((script) => nativeList.add(toCMLNativeScript(script)));
      return CML.NativeScript.new_script_n_of_k(
        BigInt(native.required),
        nativeList
      );
    }
  }
};
var scriptFromNative = (native) => {
  return {
    type: "Native",
    script: toCMLNativeScript(native).to_cbor_hex()
  };
};
var CMLNativeSchema = S.Union(
  S.Struct({
    ScriptPubkey: S.Struct({
      ed25519_key_hash: S.String
    })
  }),
  S.Struct({
    ScriptInvalidBefore: S.Struct({
      before: S.Number
    })
  }),
  S.Struct({
    ScriptInvalidHereafter: S.Struct({
      after: S.Number
    })
  }),
  S.Struct({
    ScriptAll: S.Struct({
      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
    })
  }),
  S.Struct({
    ScriptAny: S.Struct({
      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
    })
  }),
  S.Struct({
    ScriptNOfK: S.Struct({
      n: S.Number,
      native_scripts: S.Array(S.suspend(() => CMLNativeSchema))
    })
  })
);
var parseCMLNative = S.decodeUnknownSync(CMLNativeSchema);
var scriptFromCMLNative = (cmlNative) => {
  return {
    type: "Native",
    script: CML.NativeScript.from_json(JSON.stringify(cmlNative)).to_cbor_hex()
  };
};

// src/network.ts
function networkToId(network) {
  switch (network) {
    case "Preview":
      return 0;
    case "Preprod":
      return 0;
    case "Custom":
      return 0;
    case "Mainnet":
      return 1;
    default:
      throw new Error("Network not found");
  }
}

// src/cbor.ts
import { fromHex, toHex } from "@lucid-evolution/core-utils";
import { decode, encode } from "cbor-x";
var applyDoubleCborEncoding = (script) => {
  try {
    decode(decode(fromHex(script)));
    return script;
  } catch (error) {
    try {
      decode(fromHex(script));
      return toHex(Uint8Array.from(encode(fromHex(script).buffer)));
    } catch (error2) {
      return toHex(Uint8Array.from(encode(encode(fromHex(script).buffer))));
    }
  }
};
var applySingleCborEncoding = (script) => {
  try {
    decode(decode(fromHex(script)));
    return toHex(decode(fromHex(script)));
  } catch (error) {
    try {
      decode(fromHex(script));
      return script;
    } catch (error2) {
      return toHex(Uint8Array.from(encode(fromHex(script).buffer)));
    }
  }
};
var CBOREncodingLevel = (script) => {
  try {
    decode(decode(fromHex(script)));
    return "double";
  } catch (error) {
    try {
      decode(fromHex(script));
      return "single";
    } catch (error2) {
      throw new Error("Script is not CBOR-encoded or invalid format.");
    }
  }
};
function datumJsonToCbor(json) {
  const convert = (json2) => {
    if (!isNaN(json2.int)) {
      const plutusBigInt = CML.BigInteger.from_str(json2.int.toString());
      return CML.PlutusData.new_integer(plutusBigInt);
    } else if (json2.bytes || !isNaN(Number(json2.bytes))) {
      return CML.PlutusData.new_bytes(fromHex(json2.bytes));
    } else if (json2.list) {
      const l = CML.PlutusDataList.new();
      json2.list.forEach((v) => {
        l.add(convert(v));
      });
      return CML.PlutusData.new_list(l);
    } else if (json2.map && json2.map.length > 0 && typeof json2.map[0] === "object") {
      const m = CML.PlutusMap.new();
      json2.map.forEach(({ k, v }) => {
        m.set(convert(k), convert(v));
      });
      return CML.PlutusData.new_map(m);
    } else if (json2.map && typeof json2.map === "function") {
      const l = CML.PlutusDataList.new();
      Object.values(json2).forEach((value) => {
        l.add(convert(value));
      });
      return CML.PlutusData.new_list(l);
    } else if (!isNaN(json2.constructor)) {
      const l = CML.PlutusDataList.new();
      json2.fields.forEach((v) => {
        l.add(convert(v));
      });
      const bigInt = CML.BigInteger.from_str(
        json2.constructor.toString()
      ).as_u64();
      return CML.PlutusData.new_constr_plutus_data(
        CML.ConstrPlutusData.new(bigInt, l)
      );
    }
    throw new Error("Unsupported type");
  };
  return convert(json).to_cbor_hex();
}

// src/scripts.ts
import { Data } from "@lucid-evolution/plutus";
import {
  Application,
  encodeUPLC,
  parseUPLC,
  UPLCConst,
  UPLCProgram
} from "@harmoniclabs/uplc";
import { fromHex as fromHex2, toHex as toHex2 } from "@lucid-evolution/core-utils";
import { decode as decode2 } from "cbor-x";
import { dataFromCbor } from "@harmoniclabs/plutus-data";
function validatorToAddress(network, validator, stakeCredential) {
  const validatorHash = validatorToScriptHash(validator);
  if (stakeCredential) {
    return CML.BaseAddress.new(
      networkToId(network),
      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash)),
      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(stakeCredential.hash)
      )
    ).to_address().to_bech32(void 0);
  } else {
    return CML.EnterpriseAddress.new(
      networkToId(network),
      CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
    ).to_address().to_bech32(void 0);
  }
}
function validatorToScriptHash(validator) {
  switch (validator.type) {
    case "Native":
      return CML.NativeScript.from_cbor_hex(validator.script).hash().to_hex();
    case "PlutusV1":
      return CML.PlutusScript.from_v1(
        CML.PlutusV1Script.from_cbor_hex(
          applyDoubleCborEncoding(validator.script)
        )
      ).hash().to_hex();
    case "PlutusV2":
      return CML.PlutusScript.from_v2(
        CML.PlutusV2Script.from_cbor_hex(
          applyDoubleCborEncoding(validator.script)
        )
      ).hash().to_hex();
    case "PlutusV3":
      return CML.PlutusScript.from_v3(
        CML.PlutusV3Script.from_cbor_hex(
          applyDoubleCborEncoding(validator.script)
        )
      ).hash().to_hex();
    default:
      throw new Error("No variant matched");
  }
}
function toScriptRef(script) {
  switch (script.type) {
    case "Native":
      return CML.Script.new_native(
        CML.NativeScript.from_cbor_hex(script.script)
      );
    case "PlutusV1":
      return CML.Script.new_plutus_v1(
        CML.PlutusV1Script.from_cbor_hex(
          applyDoubleCborEncoding(script.script)
        )
      );
    case "PlutusV2":
      return CML.Script.new_plutus_v2(
        CML.PlutusV2Script.from_cbor_hex(
          applyDoubleCborEncoding(script.script)
        )
      );
    case "PlutusV3":
      return CML.Script.new_plutus_v3(
        CML.PlutusV3Script.from_cbor_hex(
          applyDoubleCborEncoding(script.script)
        )
      );
    default:
      throw new Error("No variant matched.");
  }
}
function fromScriptRef(scriptRef) {
  const kind = scriptRef.kind();
  switch (kind) {
    case 0:
      return {
        type: "Native",
        script: scriptRef.as_native().to_cbor_hex()
      };
    case 1:
      return {
        type: "PlutusV1",
        script: scriptRef.as_plutus_v1().to_cbor_hex()
      };
    case 2:
      return {
        type: "PlutusV2",
        script: scriptRef.as_plutus_v2().to_cbor_hex()
      };
    case 3:
      return {
        type: "PlutusV3",
        script: scriptRef.as_plutus_v3().to_cbor_hex()
      };
    default:
      throw new Error("No variant matched.");
  }
}
function mintingPolicyToId(mintingPolicy) {
  return validatorToScriptHash(mintingPolicy);
}
function applyParamsToScript(plutusScript, params, type) {
  const program = parseUPLC(
    decode2(decode2(fromHex2(applyDoubleCborEncoding(plutusScript)))),
    "flat"
  );
  const parameters = type ? Data.castTo(params, type) : params;
  const appliedProgram = parameters.reduce((body, currentParameter) => {
    const data = UPLCConst.data(dataFromCbor(Data.to(currentParameter)));
    const appliedParameter = new Application(body, data);
    return appliedParameter;
  }, program.body);
  return applyDoubleCborEncoding(
    toHex2(
      encodeUPLC(new UPLCProgram(program.version, appliedProgram)).toBuffer().buffer
    )
  );
}

// src/address.ts
function addressFromHexOrBech32(address) {
  try {
    return CML.Address.from_hex(address);
  } catch (_e) {
    try {
      return CML.Address.from_bech32(address);
    } catch (_e2) {
      throw new Error("Could not deserialize address.");
    }
  }
}
function credentialToRewardAddress(network, stakeCredential) {
  return CML.RewardAddress.new(
    networkToId(network),
    stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
      CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
    ) : CML.Credential.new_script(
      CML.ScriptHash.from_hex(stakeCredential.hash)
    )
  ).to_address().to_bech32(void 0);
}
function validatorToRewardAddress(network, validator) {
  const validatorHash = validatorToScriptHash(validator);
  return CML.RewardAddress.new(
    networkToId(network),
    CML.Credential.new_script(CML.ScriptHash.from_hex(validatorHash))
  ).to_address().to_bech32(void 0);
}
function getAddressDetails(address) {
  try {
    const parsedAddress = CML.BaseAddress.from_address(
      addressFromHexOrBech32(address)
    );
    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
      type: "Key",
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      hash: parsedAddress.payment().as_script().to_hex()
    };
    const stakeCredential = parsedAddress.stake().kind() === 0 ? {
      type: "Key",
      hash: parsedAddress.stake().as_pub_key().to_hex()
    } : {
      type: "Script",
      hash: parsedAddress.stake().as_script().to_hex()
    };
    return {
      type: "Base",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        hex: parsedAddress.to_address().to_hex()
      },
      paymentCredential,
      stakeCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = CML.EnterpriseAddress.from_address(
      addressFromHexOrBech32(address)
    );
    const paymentCredential = parsedAddress.payment().kind() === 0 ? {
      type: "Key",
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      hash: parsedAddress.payment().as_script().to_hex()
    };
    return {
      type: "Enterprise",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        hex: parsedAddress.to_address().to_hex()
      },
      paymentCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = CML.PointerAddress.from_address(
      addressFromHexOrBech32(address)
    );
    const paymentCredential = parsedAddress?.payment().kind() === 0 ? {
      type: "Key",
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      hash: parsedAddress.payment().as_script().to_hex()
    };
    return {
      type: "Pointer",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        hex: parsedAddress.to_address().to_hex()
      },
      paymentCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = CML.RewardAddress.from_address(
      addressFromHexOrBech32(address)
    );
    const stakeCredential = parsedAddress.payment().kind() === 0 ? {
      type: "Key",
      hash: parsedAddress.payment().as_pub_key().to_hex()
    } : {
      type: "Script",
      hash: parsedAddress.payment().as_script().to_hex()
    };
    return {
      type: "Reward",
      networkId: parsedAddress.to_address().network_id(),
      address: {
        bech32: parsedAddress.to_address().to_bech32(void 0),
        hex: parsedAddress.to_address().to_hex()
      },
      stakeCredential
    };
  } catch (_e) {
  }
  try {
    const parsedAddress = ((address2) => {
      try {
        return CML.ByronAddress.from_cbor_hex(address2);
      } catch (_e) {
        try {
          return CML.ByronAddress.from_base58(address2);
        } catch (_e2) {
          throw new Error("Could not deserialize address.");
        }
      }
    })(address);
    return {
      type: "Byron",
      networkId: parsedAddress.content().network_id(),
      address: {
        bech32: "",
        hex: parsedAddress.to_address().to_hex()
      }
    };
  } catch (_e) {
  }
  throw new Error("No address type matched for: " + address);
}

// src/cost_model.ts
function createCostModels(costModels) {
  const costmodel = {
    0: [],
    1: [],
    2: []
  };
  for (const cost of Object.values(costModels.PlutusV1)) {
    costmodel[0]?.push(cost);
  }
  for (const cost of Object.values(costModels.PlutusV2)) {
    costmodel[1]?.push(cost);
  }
  for (const cost of Object.values(costModels.PlutusV3)) {
    costmodel[2]?.push(cost);
  }
  return CML.CostModels.from_json(JSON.stringify(costmodel));
}
var PROTOCOL_PARAMETERS_DEFAULT = {
  minFeeA: 44,
  minFeeB: 155381,
  maxTxSize: 16384,
  maxValSize: 5e3,
  keyDeposit: 2000000n,
  poolDeposit: 500000000n,
  drepDeposit: 500000000n,
  govActionDeposit: 100000000000n,
  priceMem: 0.0577,
  priceStep: 721e-7,
  maxTxExMem: 14000000n,
  maxTxExSteps: 10000000000n,
  coinsPerUtxoByte: 4310n,
  collateralPercentage: 150,
  maxCollateralInputs: 3,
  minFeeRefScriptCostPerByte: 15,
  costModels: {
    PlutusV1: {
      "0": 100788,
      "1": 420,
      "2": 1,
      "3": 1,
      "4": 1e3,
      "5": 173,
      "6": 0,
      "7": 1,
      "8": 1e3,
      "9": 59957,
      "10": 4,
      "11": 1,
      "12": 11183,
      "13": 32,
      "14": 201305,
      "15": 8356,
      "16": 4,
      "17": 16e3,
      "18": 100,
      "19": 16e3,
      "20": 100,
      "21": 16e3,
      "22": 100,
      "23": 16e3,
      "24": 100,
      "25": 16e3,
      "26": 100,
      "27": 16e3,
      "28": 100,
      "29": 100,
      "30": 100,
      "31": 16e3,
      "32": 100,
      "33": 94375,
      "34": 32,
      "35": 132994,
      "36": 32,
      "37": 61462,
      "38": 4,
      "39": 72010,
      "40": 178,
      "41": 0,
      "42": 1,
      "43": 22151,
      "44": 32,
      "45": 91189,
      "46": 769,
      "47": 4,
      "48": 2,
      "49": 85848,
      "50": 228465,
      "51": 122,
      "52": 0,
      "53": 1,
      "54": 1,
      "55": 1e3,
      "56": 42921,
      "57": 4,
      "58": 2,
      "59": 24548,
      "60": 29498,
      "61": 38,
      "62": 1,
      "63": 898148,
      "64": 27279,
      "65": 1,
      "66": 51775,
      "67": 558,
      "68": 1,
      "69": 39184,
      "70": 1e3,
      "71": 60594,
      "72": 1,
      "73": 141895,
      "74": 32,
      "75": 83150,
      "76": 32,
      "77": 15299,
      "78": 32,
      "79": 76049,
      "80": 1,
      "81": 13169,
      "82": 4,
      "83": 22100,
      "84": 10,
      "85": 28999,
      "86": 74,
      "87": 1,
      "88": 28999,
      "89": 74,
      "90": 1,
      "91": 43285,
      "92": 552,
      "93": 1,
      "94": 44749,
      "95": 541,
      "96": 1,
      "97": 33852,
      "98": 32,
      "99": 68246,
      "100": 32,
      "101": 72362,
      "102": 32,
      "103": 7243,
      "104": 32,
      "105": 7391,
      "106": 32,
      "107": 11546,
      "108": 32,
      "109": 85848,
      "110": 228465,
      "111": 122,
      "112": 0,
      "113": 1,
      "114": 1,
      "115": 90434,
      "116": 519,
      "117": 0,
      "118": 1,
      "119": 74433,
      "120": 32,
      "121": 85848,
      "122": 228465,
      "123": 122,
      "124": 0,
      "125": 1,
      "126": 1,
      "127": 85848,
      "128": 228465,
      "129": 122,
      "130": 0,
      "131": 1,
      "132": 1,
      "133": 270652,
      "134": 22588,
      "135": 4,
      "136": 1457325,
      "137": 64566,
      "138": 4,
      "139": 20467,
      "140": 1,
      "141": 4,
      "142": 0,
      "143": 141992,
      "144": 32,
      "145": 100788,
      "146": 420,
      "147": 1,
      "148": 1,
      "149": 81663,
      "150": 32,
      "151": 59498,
      "152": 32,
      "153": 20142,
      "154": 32,
      "155": 24588,
      "156": 32,
      "157": 20744,
      "158": 32,
      "159": 25933,
      "160": 32,
      "161": 24623,
      "162": 32,
      "163": 53384111,
      "164": 14333,
      "165": 10
    },
    PlutusV2: {
      "0": 100788,
      "1": 420,
      "2": 1,
      "3": 1,
      "4": 1e3,
      "5": 173,
      "6": 0,
      "7": 1,
      "8": 1e3,
      "9": 59957,
      "10": 4,
      "11": 1,
      "12": 11183,
      "13": 32,
      "14": 201305,
      "15": 8356,
      "16": 4,
      "17": 16e3,
      "18": 100,
      "19": 16e3,
      "20": 100,
      "21": 16e3,
      "22": 100,
      "23": 16e3,
      "24": 100,
      "25": 16e3,
      "26": 100,
      "27": 16e3,
      "28": 100,
      "29": 100,
      "30": 100,
      "31": 16e3,
      "32": 100,
      "33": 94375,
      "34": 32,
      "35": 132994,
      "36": 32,
      "37": 61462,
      "38": 4,
      "39": 72010,
      "40": 178,
      "41": 0,
      "42": 1,
      "43": 22151,
      "44": 32,
      "45": 91189,
      "46": 769,
      "47": 4,
      "48": 2,
      "49": 85848,
      "50": 228465,
      "51": 122,
      "52": 0,
      "53": 1,
      "54": 1,
      "55": 1e3,
      "56": 42921,
      "57": 4,
      "58": 2,
      "59": 24548,
      "60": 29498,
      "61": 38,
      "62": 1,
      "63": 898148,
      "64": 27279,
      "65": 1,
      "66": 51775,
      "67": 558,
      "68": 1,
      "69": 39184,
      "70": 1e3,
      "71": 60594,
      "72": 1,
      "73": 141895,
      "74": 32,
      "75": 83150,
      "76": 32,
      "77": 15299,
      "78": 32,
      "79": 76049,
      "80": 1,
      "81": 13169,
      "82": 4,
      "83": 22100,
      "84": 10,
      "85": 28999,
      "86": 74,
      "87": 1,
      "88": 28999,
      "89": 74,
      "90": 1,
      "91": 43285,
      "92": 552,
      "93": 1,
      "94": 44749,
      "95": 541,
      "96": 1,
      "97": 33852,
      "98": 32,
      "99": 68246,
      "100": 32,
      "101": 72362,
      "102": 32,
      "103": 7243,
      "104": 32,
      "105": 7391,
      "106": 32,
      "107": 11546,
      "108": 32,
      "109": 85848,
      "110": 228465,
      "111": 122,
      "112": 0,
      "113": 1,
      "114": 1,
      "115": 90434,
      "116": 519,
      "117": 0,
      "118": 1,
      "119": 74433,
      "120": 32,
      "121": 85848,
      "122": 228465,
      "123": 122,
      "124": 0,
      "125": 1,
      "126": 1,
      "127": 85848,
      "128": 228465,
      "129": 122,
      "130": 0,
      "131": 1,
      "132": 1,
      "133": 955506,
      "134": 213312,
      "135": 0,
      "136": 2,
      "137": 270652,
      "138": 22588,
      "139": 4,
      "140": 1457325,
      "141": 64566,
      "142": 4,
      "143": 20467,
      "144": 1,
      "145": 4,
      "146": 0,
      "147": 141992,
      "148": 32,
      "149": 100788,
      "150": 420,
      "151": 1,
      "152": 1,
      "153": 81663,
      "154": 32,
      "155": 59498,
      "156": 32,
      "157": 20142,
      "158": 32,
      "159": 24588,
      "160": 32,
      "161": 20744,
      "162": 32,
      "163": 25933,
      "164": 32,
      "165": 24623,
      "166": 32,
      "167": 43053543,
      "168": 10,
      "169": 53384111,
      "170": 14333,
      "171": 10,
      "172": 43574283,
      "173": 26308,
      "174": 10
    },
    PlutusV3: {
      "0": 100788,
      "1": 420,
      "2": 1,
      "3": 1,
      "4": 1e3,
      "5": 173,
      "6": 0,
      "7": 1,
      "8": 1e3,
      "9": 59957,
      "10": 4,
      "11": 1,
      "12": 11183,
      "13": 32,
      "14": 201305,
      "15": 8356,
      "16": 4,
      "17": 16e3,
      "18": 100,
      "19": 16e3,
      "20": 100,
      "21": 16e3,
      "22": 100,
      "23": 16e3,
      "24": 100,
      "25": 16e3,
      "26": 100,
      "27": 16e3,
      "28": 100,
      "29": 100,
      "30": 100,
      "31": 16e3,
      "32": 100,
      "33": 94375,
      "34": 32,
      "35": 132994,
      "36": 32,
      "37": 61462,
      "38": 4,
      "39": 72010,
      "40": 178,
      "41": 0,
      "42": 1,
      "43": 22151,
      "44": 32,
      "45": 91189,
      "46": 769,
      "47": 4,
      "48": 2,
      "49": 85848,
      "50": 123203,
      "51": 7305,
      "52": -900,
      "53": 1716,
      "54": 549,
      "55": 57,
      "56": 85848,
      "57": 0,
      "58": 1,
      "59": 1,
      "60": 1e3,
      "61": 42921,
      "62": 4,
      "63": 2,
      "64": 24548,
      "65": 29498,
      "66": 38,
      "67": 1,
      "68": 898148,
      "69": 27279,
      "70": 1,
      "71": 51775,
      "72": 558,
      "73": 1,
      "74": 39184,
      "75": 1e3,
      "76": 60594,
      "77": 1,
      "78": 141895,
      "79": 32,
      "80": 83150,
      "81": 32,
      "82": 15299,
      "83": 32,
      "84": 76049,
      "85": 1,
      "86": 13169,
      "87": 4,
      "88": 22100,
      "89": 10,
      "90": 28999,
      "91": 74,
      "92": 1,
      "93": 28999,
      "94": 74,
      "95": 1,
      "96": 43285,
      "97": 552,
      "98": 1,
      "99": 44749,
      "100": 541,
      "101": 1,
      "102": 33852,
      "103": 32,
      "104": 68246,
      "105": 32,
      "106": 72362,
      "107": 32,
      "108": 7243,
      "109": 32,
      "110": 7391,
      "111": 32,
      "112": 11546,
      "113": 32,
      "114": 85848,
      "115": 123203,
      "116": 7305,
      "117": -900,
      "118": 1716,
      "119": 549,
      "120": 57,
      "121": 85848,
      "122": 0,
      "123": 1,
      "124": 90434,
      "125": 519,
      "126": 0,
      "127": 1,
      "128": 74433,
      "129": 32,
      "130": 85848,
      "131": 123203,
      "132": 7305,
      "133": -900,
      "134": 1716,
      "135": 549,
      "136": 57,
      "137": 85848,
      "138": 0,
      "139": 1,
      "140": 1,
      "141": 85848,
      "142": 123203,
      "143": 7305,
      "144": -900,
      "145": 1716,
      "146": 549,
      "147": 57,
      "148": 85848,
      "149": 0,
      "150": 1,
      "151": 955506,
      "152": 213312,
      "153": 0,
      "154": 2,
      "155": 270652,
      "156": 22588,
      "157": 4,
      "158": 1457325,
      "159": 64566,
      "160": 4,
      "161": 20467,
      "162": 1,
      "163": 4,
      "164": 0,
      "165": 141992,
      "166": 32,
      "167": 100788,
      "168": 420,
      "169": 1,
      "170": 1,
      "171": 81663,
      "172": 32,
      "173": 59498,
      "174": 32,
      "175": 20142,
      "176": 32,
      "177": 24588,
      "178": 32,
      "179": 20744,
      "180": 32,
      "181": 25933,
      "182": 32,
      "183": 24623,
      "184": 32,
      "185": 43053543,
      "186": 10,
      "187": 53384111,
      "188": 14333,
      "189": 10,
      "190": 43574283,
      "191": 26308,
      "192": 10,
      "193": 16e3,
      "194": 100,
      "195": 16e3,
      "196": 100,
      "197": 962335,
      "198": 18,
      "199": 2780678,
      "200": 6,
      "201": 442008,
      "202": 1,
      "203": 52538055,
      "204": 3756,
      "205": 18,
      "206": 267929,
      "207": 18,
      "208": 76433006,
      "209": 8868,
      "210": 18,
      "211": 52948122,
      "212": 18,
      "213": 1995836,
      "214": 36,
      "215": 3227919,
      "216": 12,
      "217": 901022,
      "218": 1,
      "219": 166917843,
      "220": 4307,
      "221": 36,
      "222": 284546,
      "223": 36,
      "224": 158221314,
      "225": 26549,
      "226": 36,
      "227": 74698472,
      "228": 36,
      "229": 333849714,
      "230": 1,
      "231": 254006273,
      "232": 72,
      "233": 2174038,
      "234": 72,
      "235": 2261318,
      "236": 64571,
      "237": 4,
      "238": 207616,
      "239": 8310,
      "240": 4,
      "241": 1293828,
      "242": 28716,
      "243": 63,
      "244": 0,
      "245": 1,
      "246": 1006041,
      "247": 43623,
      "248": 251,
      "249": 0,
      "250": 1,
      "251": 100181,
      "252": 726,
      "253": 719,
      "254": 0,
      "255": 1,
      "256": 100181,
      "257": 726,
      "258": 719,
      "259": 0,
      "260": 1,
      "261": 100181,
      "262": 726,
      "263": 719,
      "264": 0,
      "265": 1,
      "266": 107878,
      "267": 680,
      "268": 0,
      "269": 1,
      "270": 95336,
      "271": 1,
      "272": 281145,
      "273": 18848,
      "274": 0,
      "275": 1,
      "276": 180194,
      "277": 159,
      "278": 1,
      "279": 1,
      "280": 158519,
      "281": 8942,
      "282": 0,
      "283": 1,
      "284": 159378,
      "285": 8813,
      "286": 0,
      "287": 1,
      "288": 107490,
      "289": 3298,
      "290": 1,
      "291": 106057,
      "292": 655,
      "293": 1,
      "294": 1964219,
      "295": 24520,
      "296": 3
    }
  }
};

// src/credential.ts
import { Cardano } from "@cardano-sdk/core";
function credentialToAddress(network, paymentCredential, stakeCredential) {
  if (stakeCredential) {
    return CML.BaseAddress.new(
      networkToId(network),
      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(paymentCredential.hash)
      ),
      stakeCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(stakeCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(stakeCredential.hash)
      )
    ).to_address().to_bech32(void 0);
  } else {
    return CML.EnterpriseAddress.new(
      networkToId(network),
      paymentCredential.type === "Key" ? CML.Credential.new_pub_key(
        CML.Ed25519KeyHash.from_hex(paymentCredential.hash)
      ) : CML.Credential.new_script(
        CML.ScriptHash.from_hex(paymentCredential.hash)
      )
    ).to_address().to_bech32(void 0);
  }
}
function scriptHashToCredential(scriptHash) {
  return {
    type: "Script",
    hash: scriptHash
  };
}
function keyHashToCredential(keyHash) {
  return {
    type: "Key",
    hash: keyHash
  };
}
function paymentCredentialOf(address) {
  const { paymentCredential } = getAddressDetails(address);
  if (!paymentCredential) {
    throw new Error(
      "The specified address does not contain a payment credential."
    );
  }
  return paymentCredential;
}
function stakeCredentialOf(rewardAddress) {
  const { stakeCredential } = getAddressDetails(rewardAddress);
  if (!stakeCredential) {
    throw new Error(
      "The specified address does not contain a stake credential."
    );
  }
  return stakeCredential;
}
var drepIDToCredential = (drepID) => {
  if (!Cardano.DRepID.isValid(drepID)) {
    throw new Error(`Invalid DRep ID: ${drepID}`);
  }
  const drepId = Cardano.DRepID(drepID);
  const drepCred = Cardano.DRepID.toCredential(drepId);
  return {
    type: drepCred.type == Cardano.CredentialType.KeyHash ? "Key" : "Script",
    hash: drepCred.hash
  };
};

// src/datum.ts
function datumToHash(datum) {
  return CML.hash_plutus_data(CML.PlutusData.from_cbor_hex(datum)).to_hex();
}

// src/keys.ts
import { generateMnemonic } from "bip39";
function generatePrivateKey() {
  return CML.PrivateKey.generate_ed25519().to_bech32();
}
function generateSeedPhrase() {
  return generateMnemonic(256);
}
function toPublicKey(privateKey) {
  return CML.PrivateKey.from_bech32(privateKey).to_public().to_bech32();
}

// src/label.ts
import { fromHex as fromHex3 } from "@lucid-evolution/core-utils";
import { crc8 } from "@lucid-evolution/crc8";
function toLabel(num) {
  if (num < 0 || num > 65535) {
    throw new Error(
      `Label ${num} out of range: min label 1 - max label 65535.`
    );
  }
  const numHex = num.toString(16).padStart(4, "0");
  return "0" + numHex + checksum(numHex) + "0";
}
function fromLabel(label) {
  if (label.length !== 8 || !(label[0] === "0" && label[7] === "0")) {
    return null;
  }
  const numHex = label.slice(1, 5);
  const num = parseInt(numHex, 16);
  const check = label.slice(5, 7);
  return check === checksum(numHex) ? num : null;
}
function checksum(num) {
  return crc8(fromHex3(num)).toString(16).padStart(2, "0");
}

// src/time.ts
import {
  SLOT_CONFIG_NETWORK,
  slotToBeginUnixTime,
  unixTimeToEnclosingSlot
} from "@lucid-evolution/plutus";
function unixTimeToSlot(network, unixTime) {
  return unixTimeToEnclosingSlot(unixTime, SLOT_CONFIG_NETWORK[network]);
}
function slotToUnixTime(network, slot) {
  return slotToBeginUnixTime(slot, SLOT_CONFIG_NETWORK[network]);
}

// src/value.ts
import { fromHex as fromHex4, toHex as toHex3 } from "@lucid-evolution/core-utils";
import { pipe } from "effect";
function valueToAssets(value) {
  const assets = {};
  assets["lovelace"] = value.coin();
  if (value.has_multiassets()) {
    const ma = value.multi_asset();
    const multiAssets = ma.keys();
    for (let j = 0; j < multiAssets.len(); j++) {
      const policy = multiAssets.get(j);
      const policyAssets = ma.get_assets(policy);
      const assetNames = policyAssets.keys();
      for (let k = 0; k < assetNames.len(); k++) {
        const policyAsset = assetNames.get(k);
        const quantity = policyAssets.get(policyAsset);
        const unit = policy.to_hex() + policyAsset.to_js_value();
        assets[unit] = quantity;
      }
    }
  }
  return assets;
}
function assetsToValue(assets) {
  const multiAsset = CML.MultiAsset.new();
  const lovelace = assets["lovelace"] ? BigInt(assets["lovelace"]) : 0n;
  const units = Object.keys(assets);
  const policies = Array.from(
    new Set(
      units.filter((unit) => unit !== "lovelace").map((unit) => unit.slice(0, 56))
    )
  );
  for (const policy of policies) {
    const policyUnits = units.filter((unit) => unit.slice(0, 56) === policy);
    const assetsValue = CML.MapAssetNameToCoin.new();
    for (const unit of policyUnits) {
      assetsValue.insert(
        CML.AssetName.from_hex(unit.slice(56)),
        BigInt(assets[unit])
      );
    }
    multiAsset.insert_assets(CML.ScriptHash.from_hex(policy), assetsValue);
  }
  return CML.Value.new(lovelace, multiAsset);
}
function fromUnit(unit) {
  const policyId = unit.slice(0, 56);
  const assetName = unit.slice(56) || null;
  const label = fromLabel(unit.slice(56, 64));
  const name = (() => {
    const hexName = Number.isInteger(label) ? unit.slice(64) : unit.slice(56);
    return hexName || null;
  })();
  return { policyId, assetName, name, label };
}
function toUnit(policyId, name, label) {
  const hexLabel = Number.isInteger(label) ? toLabel(label) : "";
  const n = name ? name : "";
  if ((n + hexLabel).length > 64) {
    throw new Error("Asset name size exceeds 32 bytes.");
  }
  if (policyId.length !== 56) {
    throw new Error(`Policy id invalid: ${policyId}.`);
  }
  return policyId + hexLabel + n;
}
function addAssets(...assets) {
  return assets.reduce((a, b) => {
    for (const k in b) {
      if (Object.hasOwn(b, k)) {
        const sum = (a[k] || 0n) + b[k];
        if (sum === 0n) {
          delete a[k];
        } else {
          a[k] = sum;
        }
      }
    }
    return a;
  }, {});
}
async function getUniqueTokenName(utxo) {
  const id = fromHex4(utxo.txHash);
  const data = new Uint8Array([utxo.outputIndex, ...id]);
  const hash = new Uint8Array(await crypto.subtle.digest("SHA3-256", data));
  return toHex3(hash);
}
var sortCanonical = (assets) => pipe(
  Object.entries(assets).sort(([aUnit], [bUnit]) => {
    const a = fromUnit(aUnit);
    const b = fromUnit(bUnit);
    if (a.policyId.length !== b.policyId.length)
      return a.policyId.length - b.policyId.length;
    if (a.policyId === b.policyId) {
      const aAssetName = a.assetName || "";
      const bAssetName = b.assetName || "";
      if (aAssetName.length !== bAssetName.length)
        return aAssetName.length - bAssetName.length;
      return aAssetName.localeCompare(bAssetName);
    }
    return a.policyId.localeCompare(b.policyId);
  }),
  Object.fromEntries
);

// src/utxo.ts
var utxoToTransactionOutput = (utxo) => {
  return buildOutput(utxo).with_value(assetsToValue(utxo.assets)).build().output();
};
var utxoToTransactionInput = (utxo) => {
  return CML.TransactionInput.new(
    CML.TransactionHash.from_hex(utxo.txHash),
    BigInt(utxo.outputIndex)
  );
};
var utxoToCore = (utxo) => {
  const out = utxoToTransactionOutput(utxo);
  const utxoCore = CML.TransactionUnspentOutput.new(
    utxoToTransactionInput(utxo),
    out
  );
  return utxoCore;
};
function utxosToCores(utxos) {
  const result = [];
  for (const utxo of utxos) {
    result.push(utxoToCore(utxo));
  }
  return result;
}
function coreToUtxo(coreUtxo) {
  const utxo = {
    ...coreToOutRef(coreUtxo.input()),
    ...coreToTxOutput(coreUtxo.output())
  };
  return utxo;
}
function coresToUtxos(utxos) {
  const result = [];
  for (let i = 0; i < utxos.length; i++) {
    result.push(coreToUtxo(utxos[i]));
  }
  return result;
}
function coreToOutRef(input) {
  return {
    txHash: input.transaction_id().to_hex(),
    outputIndex: parseInt(input.index().toString())
  };
}
function coresToOutRefs(inputs) {
  const result = [];
  for (let i = 0; i < inputs.length; i++) {
    result.push(coreToOutRef(inputs[i]));
  }
  return result;
}
function coreToTxOutput(output) {
  return {
    assets: valueToAssets(output.amount()),
    address: output.address().to_bech32(void 0),
    datumHash: output.datum()?.as_hash()?.to_hex(),
    datum: output.datum()?.as_datum()?.to_cbor_hex(),
    scriptRef: output.script_ref() && fromScriptRef(output.script_ref())
  };
}
function coresToTxOutputs(outputs) {
  let result = [];
  for (let i = 0; i < outputs.length; i++) {
    result.push(coreToTxOutput(outputs[i]));
  }
  return result;
}
var selectUTxOs = (utxos, totalAssets, includeUTxOsWithScriptRef = false) => {
  const selectedUtxos = [];
  let isSelected = false;
  const assetsRequired = new Map(Object.entries(totalAssets));
  for (const utxo of utxos) {
    if (!includeUTxOsWithScriptRef && utxo.scriptRef) continue;
    isSelected = false;
    for (const [unit, amount] of assetsRequired) {
      if (Object.hasOwn(utxo.assets, unit)) {
        const utxoAmount = utxo.assets[unit];
        if (utxoAmount >= amount) {
          assetsRequired.delete(unit);
        } else {
          assetsRequired.set(unit, amount - utxoAmount);
        }
        isSelected = true;
      }
    }
    if (isSelected) {
      selectedUtxos.push(utxo);
    }
    if (assetsRequired.size == 0) {
      break;
    }
  }
  if (assetsRequired.size > 0) return [];
  return selectedUtxos;
};
var sortUTxOs = (utxos, order = "LargestFirst") => {
  switch (order) {
    case "LargestFirst":
      return [...utxos].sort(largestFirst);
    case "SmallestFirst":
      return [...utxos].sort(smallestFirst);
    case "Canonical":
      return [...utxos].sort(canonical);
  }
};
var largestFirst = (a, b) => {
  const lovelaceA = Number(a.assets["lovelace"]);
  const lovelaceB = Number(b.assets["lovelace"]);
  if (lovelaceA === lovelaceB) {
    return Object.keys(a.assets).length - Object.keys(b.assets).length;
  }
  return -1 * (lovelaceA - lovelaceB);
};
var smallestFirst = (a, b) => {
  const lovelaceA = Number(a.assets["lovelace"]);
  const lovelaceB = Number(b.assets["lovelace"]);
  if (lovelaceA == lovelaceB) {
    return Object.keys(a.assets).length - Object.keys(b.assets).length;
  }
  return lovelaceA - lovelaceB;
};
var canonical = (a, b) => {
  if (a.txHash < b.txHash) {
    return -1;
  } else if (a.txHash > b.txHash) {
    return 1;
  } else {
    return a.outputIndex - b.outputIndex;
  }
};
var isEqualUTxO = (self, that) => self.txHash === that.txHash && self.outputIndex === that.outputIndex;
function getInputIndices(indexInputs, allInputs, sorted = false) {
  const sortedInputs = sorted ? allInputs : sortUTxOs(allInputs, "Canonical");
  const indicesMap = /* @__PURE__ */ new Map();
  sortedInputs.forEach((value, index) => {
    indicesMap.set(value.txHash + value.outputIndex, BigInt(index));
  });
  return indexInputs.flatMap((value) => {
    const index = indicesMap.get(value.txHash + value.outputIndex);
    if (index !== void 0) return index;
    else return [];
  });
}
var calculateMinLovelaceFromUTxO = (coinsPerUtxoByte, utxo) => buildOutput(utxo).with_asset_and_min_required_coin(
  assetsToValue(utxo.assets).multi_asset(),
  coinsPerUtxoByte
).build().output().amount().coin();
var buildOutput = (utxo) => {
  const builder = CML.TransactionOutputBuilder.new().with_address(
    CML.Address.from_bech32(utxo.address)
  );
  return utxo.scriptRef ? buildDatum(utxo, builder).with_reference_script(toScriptRef(utxo.scriptRef)).next() : buildDatum(utxo, builder).next();
};
var buildDatum = (utxo, builder) => {
  if (utxo.datumHash && utxo.datum)
    return builder.with_communication_data(
      CML.PlutusData.from_cbor_hex(utxo.datum)
    );
  if (utxo.datum)
    return builder.with_data(
      CML.DatumOption.new_datum(CML.PlutusData.from_cbor_hex(utxo.datum))
    );
  return builder;
};

// src/objects.ts
var stringify = (data) => JSON.stringify(
  data,
  (key, value) => typeof value === "bigint" ? value.toString() + "n" : value,
  2
);

// src/redeemer.ts
var toCMLRedeemerTag = (tag) => {
  switch (tag) {
    case "spend":
      return CML.RedeemerTag.Spend;
    case "mint":
      return CML.RedeemerTag.Mint;
    case "publish":
      return CML.RedeemerTag.Cert;
    case "withdraw":
      return CML.RedeemerTag.Reward;
    case "vote":
      return CML.RedeemerTag.Voting;
    case "propose":
      return CML.RedeemerTag.Proposing;
    default:
      throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
  }
};
var fromCMLRedeemerTag = (tag) => {
  switch (tag) {
    case CML.RedeemerTag.Spend:
      return "spend";
    case CML.RedeemerTag.Mint:
      return "mint";
    case CML.RedeemerTag.Cert:
      return "publish";
    case CML.RedeemerTag.Reward:
      return "withdraw";
    case CML.RedeemerTag.Voting:
      return "vote";
    case CML.RedeemerTag.Proposing:
      return "propose";
    default:
      throw new Error(`Exhaustive check failed: Unhandled case ${tag}`);
  }
};
export {
  CBOREncodingLevel,
  PROTOCOL_PARAMETERS_DEFAULT,
  addAssets,
  addressFromHexOrBech32,
  applyDoubleCborEncoding,
  applyParamsToScript,
  applySingleCborEncoding,
  assetsToValue,
  calculateMinLovelaceFromUTxO,
  coreToOutRef,
  coreToTxOutput,
  coreToUtxo,
  coresToOutRefs,
  coresToTxOutputs,
  coresToUtxos,
  createCostModels,
  credentialToAddress,
  credentialToRewardAddress,
  datumJsonToCbor,
  datumToHash,
  drepIDToCredential,
  fromCMLRedeemerTag,
  fromLabel,
  fromScriptRef,
  fromUnit,
  generatePrivateKey,
  generateSeedPhrase,
  getAddressDetails,
  getInputIndices,
  getUniqueTokenName,
  isEqualUTxO,
  keyHashToCredential,
  mintingPolicyToId,
  networkToId,
  parseCMLNative,
  paymentCredentialOf,
  scriptFromCMLNative,
  scriptFromNative,
  scriptHashToCredential,
  selectUTxOs,
  slotToUnixTime,
  sortCanonical,
  sortUTxOs,
  stakeCredentialOf,
  stringify,
  toCMLNativeScript,
  toCMLRedeemerTag,
  toLabel,
  toPublicKey,
  toScriptRef,
  toUnit,
  unixTimeToSlot,
  utxoToCore,
  utxoToTransactionInput,
  utxoToTransactionOutput,
  utxosToCores,
  validatorToAddress,
  validatorToRewardAddress,
  validatorToScriptHash,
  valueToAssets
};
