import * as _effect_schema_AST from '@effect/schema/AST';
import { Native, Script, Network, Credential, RewardAddress, CertificateValidator, WithdrawalValidator, AddressDetails, DatumJson, Datum, CostModels, ProtocolParameters, Address, ScriptHash, KeyHash, DatumHash, PrivateKey, PublicKey, SpendingValidator, Validator, MintingPolicy, PolicyId, Exact, UnixTime, Slot, UTxO, OutRef, TxOutput, Assets, Unit, RedeemerTag } from '@lucid-evolution/core-types';
import * as CML from '@anastasia-labs/cardano-multiplatform-lib-nodejs';
import { Data } from '@lucid-evolution/plutus';

/**
 * Converts a Native type (cardano-cli JSON script syntax) to CML.NativeScript.
 *
 * Native type follows the standard described in the
 * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
 */
declare const toCMLNativeScript: (native: Native) => CML.NativeScript;
/**
 * Builds a Script from Native type (cardano-cli JSON script syntax).
 *
 * Native type follows the standard described in the
 * {@link https://github.com/IntersectMBO/cardano-node/blob/1.26.1-with-cardano-cli/doc/reference/simple-scripts.md#json-script-syntax JSON script syntax documentation}.
 */
declare const scriptFromNative: (native: Native) => Script;
/**
 * Represents a CML JSON script syntax
 */
type CMLNative = {
    ScriptPubkey: {
        ed25519_key_hash: string;
    };
} | {
    ScriptInvalidBefore: {
        before: number;
    };
} | {
    ScriptInvalidHereafter: {
        after: number;
    };
} | {
    ScriptAll: {
        native_scripts: ReadonlyArray<CMLNative>;
    };
} | {
    ScriptAny: {
        native_scripts: ReadonlyArray<CMLNative>;
    };
} | {
    ScriptNOfK: {
        n: number;
        native_scripts: ReadonlyArray<CMLNative>;
    };
};
/**
 * Parses a CMLNative type from an unknown input using effect schema.
 * This function is useful for decoding unknown data to CMLNative from a file or an API.
 *
 *  @throws {ParseError} - Throws a ParseError if the input does not conform to the schema.
 */
declare const parseCMLNative: (u: unknown, overrideOptions?: _effect_schema_AST.ParseOptions) => CMLNative;
/**
 * Builds a Script from CMLNative script type.
 *
 */
declare const scriptFromCMLNative: (cmlNative: CMLNative) => Script;

declare function addressFromHexOrBech32(address: string): CML.Address;
declare function credentialToRewardAddress(network: Network, stakeCredential: Credential): RewardAddress;
declare function validatorToRewardAddress(network: Network, validator: CertificateValidator | WithdrawalValidator): RewardAddress;
/** Address can be in Bech32 or Hex. */
declare function getAddressDetails(address: string): AddressDetails;

declare const applyDoubleCborEncoding: (script: string) => string;
declare const applySingleCborEncoding: (script: string) => string;
declare const CBOREncodingLevel: (script: string) => "double" | "single";
declare function datumJsonToCbor(json: DatumJson): Datum;

declare function createCostModels(costModels: CostModels): CML.CostModels;
declare const PROTOCOL_PARAMETERS_DEFAULT: ProtocolParameters;

declare function credentialToAddress(network: Network, paymentCredential: Credential, stakeCredential?: Credential): Address;
declare function scriptHashToCredential(scriptHash: ScriptHash): Credential;
declare function keyHashToCredential(keyHash: KeyHash): Credential;
declare function paymentCredentialOf(address: Address): Credential;
declare function stakeCredentialOf(rewardAddress: RewardAddress): Credential;
declare const drepIDToCredential: (drepID: string) => Credential;

declare function datumToHash(datum: Datum): DatumHash;

declare function generatePrivateKey(): PrivateKey;
declare function generateSeedPhrase(): string;
declare function toPublicKey(privateKey: PrivateKey): PublicKey;

declare function toLabel(num: number): string;
declare function fromLabel(label: string): number | null;

declare function networkToId(network: Network): number;

declare function validatorToAddress(network: Network, validator: SpendingValidator, stakeCredential?: Credential): Address;
declare function validatorToScriptHash(validator: Validator): ScriptHash;
declare function toScriptRef(script: Script): CML.Script;
declare function fromScriptRef(scriptRef: CML.Script): Script;
declare function mintingPolicyToId(mintingPolicy: MintingPolicy): PolicyId;
/**
 * Applies a list of parameters, in the form of the `Data` type, to a CBOR encoded script.
 *
 * The `plutusScript` must be double CBOR encoded(bytes). Ensure to use the `applyDoubleCborEncoding` function.
 */
declare function applyParamsToScript<T extends unknown[] = Data[]>(plutusScript: string, params: Exact<[...T]>, type?: T): string;

/**
 * Converts unix time to slot based on the network. For "Custom" network
 * it is advisable use `unixTimeToSlot` method from `LucidEvolution`
 * instance to avoid uninitialized `SLOT_CONFIG_NETWORK` issue. More details
 * on the issue can be found here https://github.com/Anastasia-Labs/lucid-evolution/pull/443
 * @param network
 * @param unixTime
 * @returns Slot
 */
declare function unixTimeToSlot(network: Network, unixTime: UnixTime): Slot;
declare function slotToUnixTime(network: Network, slot: Slot): UnixTime;

declare const utxoToTransactionOutput: (utxo: UTxO) => CML.TransactionOutput;
declare const utxoToTransactionInput: (utxo: UTxO) => CML.TransactionInput;
declare const utxoToCore: (utxo: UTxO) => CML.TransactionUnspentOutput;
declare function utxosToCores(utxos: UTxO[]): CML.TransactionUnspentOutput[];
declare function coreToUtxo(coreUtxo: CML.TransactionUnspentOutput): UTxO;
declare function coresToUtxos(utxos: CML.TransactionUnspentOutput[]): UTxO[];
declare function coreToOutRef(input: CML.TransactionInput): OutRef;
declare function coresToOutRefs(inputs: CML.TransactionInput[]): OutRef[];
declare function coreToTxOutput(output: CML.TransactionOutput): TxOutput;
declare function coresToTxOutputs(outputs: CML.TransactionOutput[]): TxOutput[];
/**
 * Returns a list of UTxOs whose total assets are equal to or greater than the asset value provided
 * @param utxos list of available utxos
 * @param totalAssets minimum total assets required
 * @param includeUTxOsWithScriptRef Whether to include UTxOs with scriptRef or not. default = false
 */
declare const selectUTxOs: (utxos: UTxO[], totalAssets: Assets, includeUTxOsWithScriptRef?: boolean) => UTxO[];
/**
 * Union type for specifying sorting order in function "sortUTxOs"
 */
type SortOrder = 
/**
 * Largest amount of "lovelace" with least number of unique assets first
 */
"LargestFirst"
/**
 * Smallest amount of "lovelace" with least number of unique assets first
 */
 | "SmallestFirst"
/**
 * Lexicographically sorted as per ledger rules
 */
 | "Canonical";
/**
 * Sorts an array of UTXOs according to specified sort order ("LargestFirst" by default).
 * The provided array is cloned and reference to the new sorted array is returned.
 *
 * @param {UTxO[]} utxos - The array of UTXO objects to be sorted.
 * @param {SortOrder} [order="LargestFirst"] - The order in which to sort the UTXOs.
 * @returns {UTxO[]} - The sorted array of UTXOs.
 *
 */
declare const sortUTxOs: (utxos: UTxO[], order?: SortOrder) => UTxO[];
declare const isEqualUTxO: (self: UTxO, that: UTxO) => boolean;
/**
 * Provides an array of input indices for given "indexInputs" UTxOs.
 * Indices obtained from the list of transaction inputs which are
 * ordered as per ledger rules.
 *
 * @param indexInputs Input utxos whose indices need to be returned
 * @param allInputs All the inputs utxos being spent by the transaction
 * @param sorted Whether the provided "allInputs" are sorted canonically or not
 * @returns Input indices of utxos as they appear in "indexInputs"
 */
declare function getInputIndices(indexInputs: UTxO[], allInputs: UTxO[], sorted?: Boolean): bigint[];
declare const calculateMinLovelaceFromUTxO: (coinsPerUtxoByte: bigint, utxo: UTxO) => bigint;

declare function valueToAssets(value: CML.Value): Assets;
declare function assetsToValue(assets: Assets): CML.Value;
/**
 * Splits unit into policy id, asset name (entire asset name), name (asset name without label) and label if applicable.
 * name will be returned in Hex.
 */
declare function fromUnit(unit: Unit): {
    policyId: PolicyId;
    assetName: string | null;
    name: string | null;
    label: number | null;
};
/**
 * @param name Hex encoded
 */
declare function toUnit(policyId: PolicyId, name?: string | null, label?: number | null): Unit;
declare function addAssets(...assets: Assets[]): Assets;
/**
 * Returns a unique token name which is SHA3-256 hash of UTxO's txid and idx
 * @param utxo UTxO whose OutRef will be used
 */
declare function getUniqueTokenName(utxo: UTxO): Promise<string>;
/**
 *
 * Sort Assets following [RFC 7049 Section 3.9](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9) sorting rules
 */
declare const sortCanonical: (assets: Assets) => Assets;

declare const stringify: (data: any) => string;

declare const toCMLRedeemerTag: (tag: string) => CML.RedeemerTag;
declare const fromCMLRedeemerTag: (tag: CML.RedeemerTag) => RedeemerTag;

export { CBOREncodingLevel, type CMLNative, PROTOCOL_PARAMETERS_DEFAULT, type SortOrder, addAssets, addressFromHexOrBech32, applyDoubleCborEncoding, applyParamsToScript, applySingleCborEncoding, assetsToValue, calculateMinLovelaceFromUTxO, coreToOutRef, coreToTxOutput, coreToUtxo, coresToOutRefs, coresToTxOutputs, coresToUtxos, createCostModels, credentialToAddress, credentialToRewardAddress, datumJsonToCbor, datumToHash, drepIDToCredential, fromCMLRedeemerTag, fromLabel, fromScriptRef, fromUnit, generatePrivateKey, generateSeedPhrase, getAddressDetails, getInputIndices, getUniqueTokenName, isEqualUTxO, keyHashToCredential, mintingPolicyToId, networkToId, parseCMLNative, paymentCredentialOf, scriptFromCMLNative, scriptFromNative, scriptHashToCredential, selectUTxOs, slotToUnixTime, sortCanonical, sortUTxOs, stakeCredentialOf, stringify, toCMLNativeScript, toCMLRedeemerTag, toLabel, toPublicKey, toScriptRef, toUnit, unixTimeToSlot, utxoToCore, utxoToTransactionInput, utxoToTransactionOutput, utxosToCores, validatorToAddress, validatorToRewardAddress, validatorToScriptHash, valueToAssets };
