"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  signData: () => signData,
  verifyData: () => verifyData
});
module.exports = __toCommonJS(src_exports);

// src/sign_data.ts
var import_core_utils = require("@lucid-evolution/core-utils");
var CML = __toESM(require("@anastasia-labs/cardano-multiplatform-lib-nodejs"), 1);
var M = __toESM(require("@emurgo/cardano-message-signing-nodejs"), 1);
function signData(addressHex, payload, privateKey) {
  const protectedHeaders = M.HeaderMap.new();
  protectedHeaders.set_algorithm_id(
    M.Label.from_algorithm_id(M.AlgorithmId.EdDSA)
  );
  protectedHeaders.set_header(
    M.Label.new_text("address"),
    M.CBORValue.new_bytes((0, import_core_utils.fromHex)(addressHex))
  );
  const protectedSerialized = M.ProtectedHeaderMap.new(protectedHeaders);
  const unprotectedHeaders = M.HeaderMap.new();
  const headers = M.Headers.new(protectedSerialized, unprotectedHeaders);
  const builder = M.COSESign1Builder.new(headers, (0, import_core_utils.fromHex)(payload), false);
  const toSign = builder.make_data_to_sign().to_bytes();
  const priv = CML.PrivateKey.from_bech32(privateKey);
  const signedSigStruc = priv.sign(toSign).to_raw_bytes();
  const coseSign1 = builder.build(signedSigStruc);
  const key = M.COSEKey.new(
    M.Label.from_key_type(M.KeyType.OKP)
    //OKP
  );
  key.set_algorithm_id(M.Label.from_algorithm_id(M.AlgorithmId.EdDSA));
  key.set_header(
    M.Label.new_int(M.Int.new_negative(M.BigNum.from_str("1"))),
    M.CBORValue.new_int(
      M.Int.new_i32(6)
      //M.CurveType.Ed25519
    )
  );
  key.set_header(
    M.Label.new_int(M.Int.new_negative(M.BigNum.from_str("2"))),
    M.CBORValue.new_bytes(priv.to_public().to_raw_bytes())
  );
  return {
    signature: (0, import_core_utils.toHex)(coseSign1.to_bytes()),
    key: (0, import_core_utils.toHex)(key.to_bytes())
  };
}
function verifyData(addressHex, keyHash, payload, signedMessage) {
  const cose1 = M.COSESign1.from_bytes((0, import_core_utils.fromHex)(signedMessage.signature));
  const key = M.COSEKey.from_bytes((0, import_core_utils.fromHex)(signedMessage.key));
  const protectedHeaders = cose1.headers().protected().deserialized_headers();
  const cose1Address = (() => {
    try {
      return (0, import_core_utils.toHex)(
        protectedHeaders.header(M.Label.new_text("address"))?.as_bytes()
      );
    } catch (_e) {
      throw new Error("No address found in signature.");
    }
  })();
  const cose1AlgorithmId = (() => {
    try {
      const int = protectedHeaders.algorithm_id()?.as_int();
      if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
      return parseInt(int?.as_negative()?.to_str());
    } catch (_e) {
      throw new Error("Failed to retrieve Algorithm Id.");
    }
  })();
  const keyAlgorithmId = (() => {
    try {
      const int = key.algorithm_id()?.as_int();
      if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
      return parseInt(int?.as_negative()?.to_str());
    } catch (_e) {
      throw new Error("Failed to retrieve Algorithm Id.");
    }
  })();
  const keyCurve = (() => {
    try {
      const int = key.header(M.Label.new_int(M.Int.new_negative(M.BigNum.from_str("1"))))?.as_int();
      if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
      return parseInt(int?.as_negative()?.to_str());
    } catch (_e) {
      throw new Error("Failed to retrieve Curve.");
    }
  })();
  const keyType = (() => {
    try {
      const int = key.key_type().as_int();
      if (int?.is_positive()) return parseInt(int.as_positive()?.to_str());
      return parseInt(int?.as_negative()?.to_str());
    } catch (_e) {
      throw new Error("Failed to retrieve Key Type.");
    }
  })();
  const publicKey = (() => {
    try {
      return CML.PublicKey.from_bytes(
        key.header(M.Label.new_int(M.Int.new_negative(M.BigNum.from_str("2"))))?.as_bytes()
      );
    } catch (_e) {
      throw new Error("No public key found.");
    }
  })();
  const cose1Payload = (() => {
    try {
      return (0, import_core_utils.toHex)(cose1.payload());
    } catch (_e) {
      throw new Error("No payload found.");
    }
  })();
  const signature = CML.Ed25519Signature.from_raw_bytes(cose1.signature());
  const data = cose1.signed_data(void 0, void 0).to_bytes();
  if (cose1Address !== addressHex) return false;
  if (keyHash !== publicKey.hash().to_hex()) return false;
  if (cose1AlgorithmId !== keyAlgorithmId && cose1AlgorithmId !== M.AlgorithmId.EdDSA) {
    return false;
  }
  if (keyCurve !== 6) return false;
  if (keyType !== 1) return false;
  if (cose1Payload !== payload) return false;
  return publicKey.verify(data, signature);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  signData,
  verifyData
});
