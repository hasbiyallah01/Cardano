import { Provider, ProtocolParameters, Address, Credential, UTxO, Unit, OutRef, RewardAddress, Delegation, DatumHash, Datum, TxHash, Transaction, EvalRedeemer, Assets, OutputData, UnixTime, Lovelace } from '@lucid-evolution/core-types';
import * as effect_Cause from 'effect/Cause';
import * as effect_Types from 'effect/Types';

declare class Blockfrost implements Provider {
    url: string;
    projectId: string;
    constructor(url: string, projectId?: string);
    getProtocolParameters(): Promise<ProtocolParameters>;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    private blockfrostUtxosToUtxos;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

declare const KupmiosError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "KupmiosError";
} & Readonly<A>;
declare class KupmiosError extends KupmiosError_base<{
    cause?: unknown;
}> {
    get message(): string;
}
/**
 * Provides support for interacting with both Kupo and Ogmios APIs.
 *
 * @example Using Local URLs (No Authentication):
 * ```typescript
 * const kupmios = new Kupmios(
 *   "http://localhost:1442", // Kupo API URL
 *   "http://localhost:1337"  // Ogmios API URL
 * );
 * ```
 *
 * @example Using Authenticated URLs (No Custom Headers):
 * ```typescript
 * const kupmios = new Kupmios(
 *   "https://dmtr_kupoXXX.preprod-v2.kupo-m1.demeter.run", // Kupo Authenticated URL
 *   "https://dmtr_ogmiosXXX.preprod-v6.ogmios-m1.demeter.run" // Ogmios Authenticated URL
 * );
 * ```
 *
 * @example Using Public URLs with Custom Headers:
 * ```typescript
 * const kupmios = new Kupmios(
 *   "https://preprod-v2.kupo-m1.demeter.run", // Kupo API URL
 *   "https://preprod-v6.ogmios-m1.demeter.run", // Ogmios API URL
 *   {
 *     kupoHeader: { "dmtr-api-key": "dmtr_kupoXXX" }, // Custom header for Kupo
 *     ogmiosHeader: { "dmtr-api-key": "dmtr_ogmiosXXX" } // Custom header for Ogmios
 *   }
 * );
 */
declare class Kupmios implements Provider {
    private readonly kupoUrl;
    private readonly ogmiosUrl;
    private readonly headers?;
    constructor(kupoUrl: string, ogmiosUrl: string, headers?: {
        ogmiosHeader?: Record<string, string>;
        kupoHeader?: Record<string, string>;
    });
    getProtocolParameters(): Promise<ProtocolParameters>;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: Array<OutRef>): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(cbor: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

/** Concatentation of txHash + outputIndex */
type FlatOutRef = string;
type EmulatorAccount = {
    seedPhrase: string;
    address: Address;
    assets: Assets;
    outputData?: OutputData;
    privateKey: string;
};
declare function generateEmulatorAccountFromPrivateKey(assets: Assets): EmulatorAccount;
declare function generateEmulatorAccount(assets: Assets): EmulatorAccount;
declare class Emulator implements Provider {
    ledger: Record<FlatOutRef, {
        utxo: UTxO;
        spent: boolean;
    }>;
    mempool: Record<FlatOutRef, {
        utxo: UTxO;
        spent: boolean;
    }>;
    /**
     * Only stake key registrations/delegations and rewards are tracked.
     * Other certificates are not tracked.
     */
    chain: Record<RewardAddress, {
        registeredStake: boolean;
        delegation: Delegation;
    }>;
    blockHeight: number;
    slot: number;
    time: UnixTime;
    protocolParameters: ProtocolParameters;
    datumTable: Record<DatumHash, Datum>;
    constructor(accounts: EmulatorAccount[], protocolParameters?: ProtocolParameters);
    now(): UnixTime;
    awaitSlot(length?: number): void;
    awaitBlock(height?: number): void;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getProtocolParameters(): Promise<ProtocolParameters>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getUtxoByUnit(unit: string): Promise<UTxO>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    awaitTx(txHash: string): Promise<boolean>;
    /**
     * Emulates the behaviour of the reward distribution at epoch boundaries.
     * Stake keys need to be registered and delegated like on a real chain in order to receive rewards.
     */
    distributeRewards(rewards: Lovelace): void;
    submitTx(tx: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
    log(): void;
}

type MaestroSupportedNetworks = "Mainnet" | "Preprod" | "Preview";
interface MaestroConfig {
    network: MaestroSupportedNetworks;
    apiKey: string;
    turboSubmit?: boolean;
}
declare class Maestro implements Provider {
    url: string;
    apiKey: string;
    turboSubmit: boolean;
    constructor({ network, apiKey, turboSubmit }: MaestroConfig);
    getProtocolParameters(): Promise<ProtocolParameters>;
    private getUtxosInternal;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    private commonHeaders;
    private requireAmountsAsStrings;
    private maestroUtxoToUtxo;
    private getAllPagesData;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

declare const KoiosError_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "KoiosError";
} & Readonly<A>;
declare class KoiosError extends KoiosError_base<{
    cause?: unknown;
}> {
    get message(): string;
}
/**
 *  Provides support for interacting with the Koios API
 *
 * @example Using the Preprod API URL:
 * ```typescript
 * const koios = new Koios(
 *   "https://preview.koios.rest/api/v1", // Preprod Preview Environment
 *   "optional-bearer-token" // Optional Bearer Token for authentication
 * );
 * ```
 *
 * @example Using the Preprod Stable API URL:
 * ```typescript
 * const koios = new Koios(
 *   "https://preprod.koios.rest/api/v1", // Preprod Stable Environment
 *   "optional-bearer-token" // Optional Bearer Token for authentication
 * );
 * ```
 *
 * @example Using the Mainnet API URL:
 * ```typescript
 * const koios = new Koios(
 *   "https://api.koios.rest/api/v1", // Mainnet Environment
 *   "optional-bearer-token" // Optional Bearer Token for authentication
 * );
 * ```
 *
 */
declare class Koios implements Provider {
    private readonly baseUrl;
    private readonly token?;
    constructor(baseUrl: string, token?: string);
    getProtocolParameters(): Promise<ProtocolParameters>;
    getUtxos(addressOrCredential: Address | Credential): Promise<UTxO[]>;
    getUtxosWithUnit(addressOrCredential: Address | Credential, unit: Unit): Promise<UTxO[]>;
    getUtxoByUnit(unit: Unit): Promise<UTxO>;
    getUtxosByOutRef(outRefs: OutRef[]): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash, checkInterval?: number): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
    evaluateTx(tx: Transaction, additionalUTxOs?: UTxO[]): Promise<EvalRedeemer[]>;
}

export { Blockfrost, Emulator, type EmulatorAccount, Koios, KoiosError, Kupmios, KupmiosError, Maestro, type MaestroConfig, type MaestroSupportedNetworks, generateEmulatorAccount, generateEmulatorAccountFromPrivateKey };
